리액트 실전 프로그래밍

## 1. 리액트 프로젝트 시작하기

### 	- 리액트란 무엇인가

* 자동으로 업데이트 되는 UI 기능만 제공

  따라서 전역 관리 상태나 라우팅, 빌드 시스템을 직접 구축해야함

* render 함수는 순수 함수로 작성

  순수 함수의 특징 입력값이 같으면 출력값이 같다.

  랜덤 함수, 날짜 함수 사용(x)

  외부 상태 변경(x)

* state는 불변 변수로 관리

  어떤 객체의 속성을 변경할 경우, 새로운 객체를 만들어서 값을 할당하는 것이다.

  => 순수 함수와 불변 변수를 활용하면 복잡도가 낮아지고 버그가 발생할 확률도 적다. 리액트의 경우 렌더링 속도도 향상 시킬 수 있는 장점이 있음

### 바벨 사용해 보기

* 자바스크립트 코드를 변환해 주는 컴파일러
* 최신 자바스크립트 문법을 지원하지 않는 환경에서도 최신 문법 사용 가능
* 그 외에도 다양한 용도로 사용
  * 코드에서 주석을 제거 or 코드를 압축
* 리액트에서는 JSX 문법을 사용하기 위해 바벨을 사용한다.

### 웹팩 사용해 보기

* 다양한 기능 제공
  * 파일 내용을 기반으로 파일 이름에 해시값 추가 => 효율적으로 브라우저 캐싱 이용
  * 사용되지 않는 코드 제거
  * 자바스크립트 압축
  * JS에서 CSS, JSON, 텍스트 파일 등을 일반 모듈처럼 불러오기
  * 환경 변수 주입
* 웹팩을 사용하는 가장 큰 이유
  => 모듈 시스템(ESM, commonJS)을 사용하고 싶어서
  * ESM : ES6에서 추가됨
  * c    ommonJS : Node에서 주로 사용

* 요즘 브라우저는 ESM을 지원한다. 하지만..
  * 오래된 브라우저도 지원해야 하는 문제
  * 많은 오픈 소스가 commonJS로 작성됨 => 요즘 브라우저는 commonJS 처리를 못하기 때문에 어쩔 수 없이 웹팩을 사용해야함.




* 실제로 불러오는 모습을 network에서 확인할 수 있다.

![image-20210618234851057](/Users/hyeonsung/Library/Application Support/typora-user-images/image-20210618234851057.png)



### create-react-app으로 시작하기

* 리액트 개발 환경을 직접 구축하기 위해 필요한 노력
  * Webpack, Babel : 빌드 시스템 구축
  * Jest : 테스트 환경 구축
  * Eslint : 코딩 컨벤션 자동 체크
  * Polyfill : 오래된 브라우저를 위한 스크립트 변환
  * HMR : Vue의 핫 리로딩과 같은 기능 (Hot Module Replacement)
  * CSS 후처리 : SASS를 사용할 경우 CSS 컴파일 과정이 필요한 것 또는 오래된 브라우저를 지원하기 위해 벤더 접두사



* cra(create-react-app)을 통해 만들 경우 단점
  * SSR을 쓸 수 없다.
  * 바벨, 웹팩, eslint 등의 설정을 변경할 수 없다.



* index.js - serviceWorker : PWA 사용할 시에 필요
  * serviceWorker.unregister() -> serviceWorker.register()



* App.js에서 로고 img를 자바스크립트에서 import해서 src에 입력을 해주고 있다.

  WHY => CSS나 img 파일을 이와 같은 방식으로 사용할 경우 이미지 경로에 해시 값이 들어가 브라우저 캐싱을 효율적으로 활용할 수 있기 때문



* data의 경우 json파일로 관리할 수 있는데 너무 큰 파일일 때 미리 import해서 무작정 받아오고 보여주는 것이 아니라 필요할 때 받아오게 할 수 있다

  HOW => 클릭되었거나 어떠한 이벤트를 기점으로 import하여 데이터를 클라이언트단에 보여주도록 함

  ```react
  function App() {
    function onClick() {
      import('.data.json').then(({ default: data}) => {
        console.log({ data });
      });
    }
  	return (
    	<button onClick={onClick}>데이터 보여주세요</button>
    )
  }
  ```




### create-react-app으로 시작하기 (2)

* __Package.json 명령어 살펴보기__ 

  * react-scripts start : 개발용, https로 실행시키고 싶다면 `HTTPS=true npm start`

    (Window OS의 경우, `set HTTPS=true && npm start`)

  * react-scripts build : 배포 시 사용, 정적 파일이 생성됨

    로컬에서 정적 파일을 서비스 하고 싶다면 `npx serve -s build` build 폴더를 대상으로 함.

    큰 사이즈의 이미지는 media 폴더에 생성이 되고 작은 사이지의 이미지는 별도 파일로 생성되지 않고 js 파일 안에 내장된다.

  * react-scripts test

    `.spec.js` 또는 `.test.js`면 테스트 파일로 인식, `__test__` 폴더 밑에 있을 경우어떤 이름이든 테스트 파일로 인식

    (개인 의견) 폴더 밑에 .test.js로 붙어있으면 여러모로 관리하기 편함

    WHY => 해당 폴더 내에 있는 기능을 테스트 하는 파일이기에 좋기 때문이라 추측

  * react-scripts eject

    모든 설정 파일을 추출하는 명령어, CRA를 기반으로 직접 개발환경을 구축한다면 사 

* __Polyfill 에 대해__
  * 쓰고자 하는 기능 caniuse.com에서 브라우저 지원 범위 확인
  * Core-js Github에서 해당 기능 경로에 대해 확인
  * CRA의 경우 기본적으로 core-js가 내장되어 있음

* __환경 변수__

  process.env.{변수 이름}

  cra에선 process.env.NODE_ENV 라는 환경변수를 갖고 있음

  실행 명령어에 따라 다르게 읽어옴

  npm start -> 'development'

  npm test -> 'test'

  npm run build -> 'production'

  process.env.REACT_APP_API_URL



### CSS 작성 방법 결정하기

* 일반적인 CSS 파일로 작성하기

  class name이 겹칠 경우 빌드 했을 때 덮어 씌워짐

* css-module로 작성하기

  import할 때 객체 형식으로 보내기 때문에 객체 형식으로 받아서 클래스명을 속성 이름으로 입력해주면 된다.

  객체 안에 속성값을 보면 뒤에 해시 값이 붙어있어 클래스 명이 같아도 고유한 이름을 가짐.

  * classnames라는 패키지를 이용하면 객체 속성 값을 보다 편하게 작성 가능 하다 => ${}의 반복 작성을 피할 수 있음

* Sass로 작성하기

  Sass 문법에 있는 변수나 믹스인 등의 개념을 이용하면 재사용성이 높은 스타일 코드를 작성할 수 있다.

* css-in-js로 작성하기

  css 코드를 js 파일 안에서 작성하는 방식으로 동적으로 css 코드를 작성하기 쉽다.

  css만 담당하는 마크업 개발팀이 별도로 있는 회사일 경우 도입하는데 어려움을 겪을 수 있다. 개발팀원 모두가 css, js를 다룰 수 있다면 도입하기 좋다!

  

  __tagged template literals 문법__

  Styled component에 사용되었던 문법으로 값(css)을 매개변수로 받아서 실행하는 함수처럼 사용

  ```js
  // in box.js 
  // BoxCommon 이라는 div로 이루어진 컴포넌트 생성
  const BoxCommon = styled.div`
    height: 50px;
    background-color: #aaaaaa;
  `;
  
  // BoxCommon을 확장하여 또 다른 컴포넌트 생성 - (1)
  const BoxBig = styled(BoxCommon)`
    width: 200px;
  `;
  
  // BoxCommon을 확장하여 또 다른 컴포넌트 생성 - (2)
  const BoxSmall = styled(BoxCommon)`
    width: 100px;
  `;
  
  // in Button.js
  // 속성 값을 받아 동적으로 처리하기
  const ButtonCommon = styled.button`
    width: ${props => (props.isBig ? 100 : 50)}px;
    height: 30px;
    background-color: yellow;
  `;
  ```

  

### SPA 만들기

![image-20210628224306464](typora-images/image-20210628224306464.png)

* Multi-Page Application **(MPA)**

  초기 요청과 이후 요청에도 모두 HTML 파일로 응답해줌.

* Single-Page Application **(SPA)**

  초기 요청에 HTML을 반환하고 이후 필요할 때만 데이터를 요청해서 받아오는 방식



* SPA가 가능하기 위한 조건

  1. 자바스크립트에서 브라우저로 페이지 전환 요청을 보낼 수 있다.

     (단, 브라우저는 서버로 요청을 보내지 않아야 한다. === 새로운 페이지에 대한 요청이 없다)

  2. 브라우저의 뒤로 가기와 같은 사용자의 페이지 전환 요청을 자바스크립트에서 처리할 수 있다.

     (마찬가지로, 브라우저는 서버로 요청을 보내지 않아야 한다.)

* 이 조건을 만족시켜주는 브라우저 API
  1. pushState, replaceState 함수
  2. popstate 이벤트



* useEffect
  1. 이벤트 핸들러 등록
  2. api를 호출 등 특정 시점에 부수 효과를 일으키고자 할 때 사용하는 리액트 함수



### 리액트 요소와 가상 돔

* **(1) 2-virtual-dom**

  브라우저에서 돔을 변경하는 것은 비교적 오래 걸리는 작업이다. **빠른 렌더링**을 위해 **돔 변경을 최소화**하는 것은 필수!! React는 메모리에 가상돔을 올려 놓고 이전과 이후의 가상돔을 비교하여 **변경된 부분만** 실제 돔에 반영한다.

  **실제 돔에 반영할 변경사항을 찾는 과정**을 따라가 보도록 한다!

  

* **(2) 가상 돔 이해하기**

  jsx 코드는 리액트 요소 트리로 구성된다.

  리액트에서 데이터 변경에 의한 화면 업데이트는 

  1. 렌더 단계 (가상 돔) => 실제 돔에 반영할 변경사항을 파악
  2. 커밋 단계 (실제 돔) => 파악된 변경 사항을 실제 돔에 반영

  을 거친다.

  렌더 단계 에서는 변경 사항을 파악하기 위해 **가상 돔**을 이용하는데 이는 리액트 요소로부터 만들어진다! React는 렌더링을 할 때마다 가상 돔을 만들고 이전 가상 돔과 비교를 한다. 이는 실제 돔의 변경 사항을 최소화하기 위한 과정이다.

  이번 코드를 기반으로 **리액트 요소가 실제 돔으로 만들어지는 과정**에 대해 알아보고자 한다.	



### 리액트 훅(Hook)

* 컴포넌트에 기능을 추가할 때 사용하는 함수

  ex) 컴포넌트에 상태값 추가, 자식 요소에 접근

  리액트 16.8에 새로 추가된 것으로 그 전엔 클래스형 컴포넌트를 사용했다. 클래스형 컴포넌트보다 장점이 많아 리액트 팀도 훅에 집중하고있다. (19년도 kakao con 에서 관련된 영상을 찾을 수 있다.) => 영상이 없어져 블로그 포스팅에 걸려있는 [발표 자료](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=horajjan&logNo=221648675404)로 대체



* 대표적인 훅 두가지!

  1. useState : 상태값 추가

     ```react
     const [{상태값}, {상태값 변경 함수}] = useState({초기값});
     const [count, setCount] = useState(0);
     // 첫 번째 아이템에는 상태값, 두 번째 아이템에는 상태값 변경 함수
     ```

     * 비동기 + 배치 처리

       ```react
       function onClick() {
         setCount(count + 1);
         setCount(count + 1);
       }
       console.log('render called');
       ```

       위와 같이 짜여있는 onClick 함수가 걸려있는 버튼을 클릭하면 count가 1씩 두번 증가할 것이라 생각하지만

       실제론 한번만 증가한다.

       비동기로 처리하는 이유는 동기로 처리할 경우 하나의 상태값 변경 함수가 호출될 때마다 화면을 다시 그리기 때문에 성능상 이슈가 생길 수 있기 때문.

       만약 억지로 위와 같이 처리하고 싶다면 상태값 변경 함수에 함수를 입력해서 다음과 같이 해결할 수 있다.

       ```react
       function onClick() {
         // 처리되기 직전의 상태값을 매개변수로 받는다
         setCount(v => v + 1);
         // 아래도 마찬가지
         setCount(v => v + 1);
       }
       console.log('render called');
       ```

       배치로 처리하는 이유는 onClick 이벤트 핸들러는 리액트 내부에서 관리되는 리액트 요소에 입력이 되어 있기 때문에 배치로 처리하는 것

       만약 리액트에서 관리하지 않는 외부에서 호출하는 경우 배치로 동작하지 않음, 이러한 경우 상태값 변경 함수를 호출할 때마다 렌더링이 발생함.

       ```react
       // 외부에서 처리하여 렌더링이 발생함.
       useEffect(() => {
         window.addEventListener('click', onClick);
         return () => window.addEventListener('click', onClick);
       })
       ```

        이런 상황에서 외부에서 처리 될 때도 배치로 처리되길 원한다면 

       ```react
       function onClick() {
         // unstable_batchedUpdated라는 함수를 호출하면 된다.
         ReactDOM.unstable_batchedUpdated(() => {
           setCount(v => v + 1);
           setCount(v => v + 1);  
         })
       }
       console.log('render called');
       ```

       앞에 unstable이라는 prefix가 붙어있긴 하지만 대부분 이런식으로 사용하고

       나중에 있을 concurrent mode가 추가된다면 외부에서 호출된 함수로 배치로 동작하게 될 것

     * 순서대로 처리된다.

       

  2. useEffect : 부수효과 처리 (여기서 부수효과란 외부의 상태를 변경하는 것을 말한다)

     * 렌더링이 끝나고 항상 호출된다. (ex, 서버 api 호출, 이벤트 핸들러 등록 등에 사용)

     * 컴포넌트 렌더링 중에 부수 효과를 발생시키는 것 프로그램의 복잡도를 크게 증가시키기에 모든 부수 효과는 useEffect 안에서 처리하기를 권장 (지키지 않는다면 유닛테스트 작성하기에 힘들어지는 등 순수 함수가 가지는 여러 장점을 포기하는 것이기 때문)

     * 렌더링이 끝나고 항상 호출되기에 만약에 렌더링이 자주 발생한다면 문제가 된다. 이것을 해결하기 위해 두 번째 매개 변수인 의존성 배열을 입력함으로써 해결할 수 있다. 이 배열에 있는 값이 변경될 때만 부수 효과 함수가 실행됩니다.

       따라서, **컴포넌트의 상태값이나 속성값**, **지역 변수나 지역 함수**같은 것들은 **모두 의존성 배열에 작성**

       <u>setUser와 같은 상태값 변경 함수는 의존성 배열에 작성하지 않아도 된다.</u> 함수가 변경되지 않는다는 것이 보장되기 때문! 

       ```react
       // Profile.js
       // 빈 배열일 경우
       useEffect(() => {
         getUserApi(userId).then(data => setUser(data));
       }, []);
       // => 의존성 배열에 아무것도 담겨있지 않기에 increase 버튼을 눌러도 부수 효과 함수가 실행되지 않고
       //    그로인해 유저 객체가 바뀌지 않음
       ```

       지역 함수인 경우

       ```react
       // Profile.js
       function func1() {
         console.log(userId)
       }
       useEffect(() => {
         func1();
         getUserApi(userId).then(data => setUser(data));
       }, [useId, func1]);
       ```

       Profile 컴포넌트가 렌더링될 때마다 func1이라는 함수가 새로 생성되고 이로 인해 의존성 배열의 값이 항상 변경된다고 볼 수 있다. 이럴 때는 **useCallback** 이라는 훅을 이용해서 **메모이제이션 기능**을 이용할 수 있다.

  3. Custom Hook 만들기

     * 이름은 use로 시작하는 것이 좋다

       코드 가독성이 좋아지고,  여러 리액트 개발 도구의 도움도 쉽게 받을 수 있기 때문

       ```react
       // Profile.js
       export default function Profile({ userId }) {
         // 1. userId가 바뀔 경우
         // 커스텀 훅(useUser) 내부에서 자동으로 api를 호출해서 사용자 데이터를 가져오고
         // 3. 그로인해 컴포넌트도 같이 새로운 유저 정보와 함께 렌더링 된다.
         const user = useUser(userId);
         return (
           <div>
             {!user && <p>사용자 정보를 가져오는 중...</p>}
             {user && (
               <>
                 <p>{`name is ${user.name}`}</p>
                 <p>{`age is ${user.age}`}</p>
               </>
             )}
           </div>
         );
       }
       
       
       // useUser.js
       export default function useUser(userId) {
         // 2. 그로 인해 내부 상태값인 user가 변경된다.
         const [user, setUser] = useState(null);
           useEffect(() => {
             getUserApi(userId).then(data => setUser(data));
           }, [userId]);
         return user;
       }
       ```

* 훅 사용 시 지켜야 할 규칙

  이 두 가지를 지켜야 리액트가 각 훅의 상태를 제대로 기억할 수 있다.

  1. 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야한다.

     If 문 안에 훅을 사용하면 안된다.

     for 문 안에서 사용하면 안된다. useState가 사용되는 횟수가 달라지기 때문

     함수 안에서 훅을 호출하면 안된다. 항상 호출되는 것이 아니기에 순서가 달라짐

     ```react
     // 잘못된 경우
     if (!user) {
       return null
     }
     const [value, setValue] = useState(0);
     /*
     user가 있으면 호출되지만 user가 없다면 호출되지 않으므로 때에 따라 훅이 다르게 호출된다
     이것을 방지하기 위해서 jsx 부분 바로 위에 return 문을 작성하여 이 둘 사이에서 훅을 사용하지 않도록 한다.
     */
     ```

     **Why? 순서가 왜 중요한가?**

     => 우리가 useState에 전달한 정보는 기본값 밖에 없다. useEffect도 마찬가지 어떤 ID 값 같은 것을 제공하지 않는다.

     ​	따라서, React 입장에선 첫 번째 사용된 useState와 두 번째 사용된 useState를 구분하기 위한 정보는 순서 정보밖에 없기 	때문이다.

  2. 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다.

     

### Context

여러 컴포넌트에서 같은 값을 받아 쓴다면 반복적으로 코드를 작성하게 될 것이다. 이를 위해 사용할 수 있는 것이 **Context** !

* Consumer를 보면 그대로 타고 올라가 가장 가까운 Provider를 찾아 값을 가져다 쓴다. 만약 없다면 CreateContext에서 선언했던 기본값을 활용!

  ```react
  const UserContext = createContext('unknown'); // 기본값과 같이 선언
  
  export default function App() {
    return (
      <div>
        <UserContext.Provider value="mike">
          <div>상단 메뉴</div>
          <Profile />
          <div>하단 메뉴</div>
        </UserContext.Provider>
      </div>
    );
  }
  
  function Profile() {
    return (
      <div>
        <Greeting />
      </div>
    );
  }
  
  function Greeting({ username }) {
    <UserContext.Consumer>
      {username => <p>{`${username}님 안녕하세요`}</p>};
    </UserContext.Consumer>
  }
  ```

* Provider에서 제공하는 value값이 변경되면  **하위의 모든 Consumer 컴포넌트는** 다시 렌더링된다.

  => 여기서 중요한 점은, 중간에 있는 Profile 컴포넌트가 렌더링 되지 않더라도 Greeting (하위) 컴포넌트는 다시 렌더링된다는 것이다. 즉 필요한 하위 컴포넌트만 리렌더링된다.
  
  ```react
  export default function App() {
    const [name, setName] = useState('mike');
    return (
      <div>
        <UserContext.Provider value={name}>
          <div>상단 메뉴</div>
          <Profile />
          <div>하단 메뉴</div>
          <input
            type="text"
            value={name}
            onChange={e => setName(e.target.value)}
          />
        </UserContext.Provider>
      </div>
    );
  }
  // Profile은 memo되어 한 번 렌더링 된 뒤에 변하지 않는다.
  // 실제로 테스트 콘솔문을 작성해두고 App인풋의 값을 변화시켜도 콘솔문이 더이상 나오지 않음을 확인할 수 있다.
  const Profile = React.memo(function() {
    console.log(Profile)
    return (
      <div>
        <Greeting />
      </div>
    );
  });
  ```

* Consumer 안에 있는 변수를 처리하고 싶다면 어떻게 해야 할까?

  ```react
  function Greeting() {
    // 이 부분에서 username을 사용할 수 없다.
    return ( 
      <UserContext.Consumer>
      	{username => <p>{`${username}님 안녕하세요`}</p>};
  	  </UserContext.Consumer>
    )
  }
  
  /*
   * username을 활용하고 싶다면?
   */
  
  // useContext 훅을 직접 사용하면 된다. 그래서 실제론 Consumer를 컴포넌트로 사용하는 일은 거의 없다.
  function Greeting() {
    const username = useContext(UserContext);
    return <p>{`${username}님 안녕하세요`}</p>;
  }
  ```

* 위에 말했던 관련된 Context만 리렌더링 되는 것을 제대로 이용하기 위해서 다른 정보와 묶어서 사용하기 보단 각각 사용해야한다! 해당하는 데이터 값의 변화가 일어났을 때 관련된 Context만 리렌더링되기 때문!

  ```react
  // ThemeContext가 변하면 ThemeContext 훅을 사용하는 부분만 리렌더링 된다.
  // useContext와는 독립적!
  function Greeting() {
    const theme = useContext(ThemeContext);
    const username = useContext(UserContext);
    return (
      <p
        style={{ color: theme === 'dark' ? 'gray' : 'green' }}
      >{`${username}님 안녕하세요`}</p>
    );
  }
  ```

* 만약 하위 컴포넌트에서 데이터를 수정하고 싶다면 어떻게 사용해야 할까?

  ```react
  // => value로 묶어서 사용할 수 있도록 한다!
  export default function App() {
    const [user, setUser] = useState({ username: 'mike', hellocount: 0 });
    return (
      <div>
        <SetUserContext.Provider value={setUser}>
          <UserContext.Provider value={user}>
            <Profile />
          </UserContext.Provider>
        </SetUserContext.Provider>
      </div>
    )
  }
  ```
  
* **Context 사용 시 주의할 점 2가지**

  value에 테스트 코드와 같은 방식으로 묶어서 입력하게 되면 App이 렌더링 될 때마다 새로운 객체가 만들어 진다. 즉, 내부 값({username, age})이 변경되지 않아도 Consumer에선 불필요하게 렌더링될 수 있다.

  * **첫 번째**

    Consumer 컴포넌트와 관계없는 count 값이 늘어나지만 Greeting이 렌더링 되는 것을 확인할 수 있다.

    ```react
    // 테스트 코드
    const UserContext = createContext({ username: 'unknown', age: 0 });
    export default function App() {
      const [username, setUsername] = useState('');
      const [age, setAge] = useState(0);
      const [count, setCount] = useState(0);
      console.log('App render')
      return (
        <div>
          <UserContext.Provider value={{ username, age }}>
            <Profile />
            <button onClick={() => setCount(count + 1)}>증가</button>
          </UserContext.Provider>
        </div>
      )
    }
    
    const Profile = React.memo(function() {
      console.log('Profile render')
      return (
        <div>
          <Greeting />
        </div>
      );
    });
    
    function Greeting() {
      console.log('Greeting render') // count가 늘어나지만 Greeting이 렌더링 된다.
      const username = useContext(UserContext);
      return <p>{`${username}님 안녕하세요`}</p>;
    }
    ```

    **필요없는 컴포넌트까지 렌더링되지 않도록 고친 코드**

    ```react
    const UserContext = createContext({ username: 'unknown', age: 0 });
    export default function App() {
      {/* 
      	const [username, setUsername] = useState('');
      	const [age, setAge] = useState(0);
      */}
      const [user, setUser] = useState({ username: 'mike', age: 0 });
      const [count, setCount] = useState(0);
      return (
        <div>
          {/* <UserContext.Provider value={{ username, age }}> */}
          <UserContext.Provider value={user}>
            <Profile />
            <button onClick={() => setCount(count + 1)}>증가</button>
          </UserContext.Provider>
        </div>
      )
    }
    ```

  * **두 번째**

    Profile의 Consumer가 올라가서 Provider를 만나지 못하는 경우 createContext의 기본값으로 선언한 unknown을 사용하게 될 것이다. 그래서 항상 Provider 컴포넌트 안에서 렌더링 되도록 작성해야 하기에 대부분 루트에서 jsx 부분 전체를 감싸는 방식으로 사용하기에 거의 그럴 일이 없다. 하지만 중간에 Provider 컴포넌트를 작성할 경우 그런 에러를 일으킬 여지가 충분히 있기에 주의를 기울여야 한다!

    ```react
    import React, { useContext, createContext } from 'react';
    
    const UserContext = createContext('unknown');
    
    export default function App() {
      return (
        {/*
        	<div>
          	에러 코드
          	<UserContext.Provider value="mike"> { ... } </UserContext.Provider>
          	<Profile />
        	</div>
        */}
        <div>
          <UserContext.Provider value="mike"}></UserContext.Provider>
          <Profile />
        </div>
      )
    }
    ```




## ref 속성값

리액트로 작업하다보면 실제 DOM 요소에 직접 접근해야 할 때가 있다. 그런 예시로는 돔 요소에 focus를 주거나 크기, 스크롤 위치를 알고 싶은 경우가 있다. 이 때 **ref 속성값**을 이용해 자식 요소에 직접 접근할 수 있는데 이는 컴포넌트일 수도, 돔 요소일 수도 있다.

* 예시 코드

  useRef 훅을 이용해 **(1) 반환된 값**을 **(2) 원하는 요소에 ref속성값으로 입력**해준다.

  ```react
  import React, { useRef, useEffect } from 'react';
  
  export default function App() {
    // (1) 반환된 값 inputRef
    const inputRef = useRef();
    useEffect(() => {
      // current라는 속성을 쓰면 실제 돔 요소를 가리키게 된다.
      inputRef.current.focus();
    }, []);
  
    return (
      <div>
      	{/* (2) 원하는 요소에 입력 input */}
        <input type="text" ref={inputRef} />
        <button>저장</button>
      </div>
    )
  } 
  ```

  **(1) 함수형 컴포넌트**와 **(2) 클래스형 컴포넌트**에서 쓰는 차이

  ```react
  import React, { useRef, useEffect } from 'react';
  
  export default function App() {
    const inputRef = useRef();
    useEffect(() => {
      inputRef.current.focus();
    }, []);
  
    return (
      <div>
        {/* 만약 클래스형 컴포넌트에 사용한다면 */}
        {/* 해당 컴포넌트의 인스턴스를 가리키고 해당 클래스의 메서드를 호출할 수 있게 된다 */}
   			{/* 함수형 컴포넌트는 인스턴스로 만들어지지 않지만 */}
        {/* useImperativeHandle이라는 훅을 사용하면 클래스 컴포넌트차람 변수와 메서드를 사용할 수 있다 */}
        <InputAndSave inputRef={inputRef} />
        <Button ref={buttonRef}>저장</Button>
        <button onClick={() => inputRef.current.focus()}>텍스트로 이동</button>
      </div>
    );
  }
  
  // 별다른 처리를 하지 않았다면 
  // 아래와 같은 함수형 컴포넌트는 인스턴스로 만들어지지 않기에 ref 속성값을 입력할 수는 없다
  // 때문에 App에서 inputRef라는 속성 이름으로 받아서 내부에 있는 자식에게 입력해주고 있다
  // 이렇게 사용해도 상관 없지만 button, input과 같이 기초적이고 직관적인 컴포넌트를 만들고자한다면
  // 그럴 때는 사실 보편적인 buttonRef, inputRef와 같은 독자적인 이름보다 일관성을 위해
  // ref로 입력하는게 좋기에 그렇게 입력하면 리액트가 내부적으로 처리하기 때문에
  // Button 컴포넌트 내부에서 그 값을 사용할 수가 없다
  // 이런 경우를 위해 forwardRef라는 함수를 사용할수 있다 
  function InputAndSave({ inputRef }) {
    return (
      <div>
        <input type="text" ref={inputRef} />
        <button>저장</button>
      </div>
    );
  }
  ```

  **ref 속성값에 함수**를 입력하여 이용할 때 흔히 하는 실수
  
  ```react
  import React, { useState, useCallback } from 'react';
  
  export default function App() {
    const [text, setText] = useState(INITIAL_TEXT);
    const [showText, setShowText] = useState(true);
  
    const setInitialText = useCallback(ref => ref && setText(INITIAL_TEXT), []);
  
    return (
      <div>
        {showText && (
          {/* useRef를 사용하지 않고 함수를 입력할 수 있다 */}
          {/* 입력한 함수는 해당하는 요소가 생성되거나 사라질 때 한 번씩 호출된다 */}
  	      {/* 생성될 때는 해당하는 요소의 레퍼런스가 넘어오고 사라질 때는 null 값이 온다 */}
          <input
            type="text"
            ref={ref => ref && setText(INITIAL_TEXT)}
            value={text}
            onChange={e => setText(e.target.value)}
          />
        	{/* 에러 발생 이유 */}
  	      {/* 컴포넌트가 렌더링 될 때마다 새로운 ref 함수를 입력하고 있기 때문인데 */}
        	{/* 리액트에선 ref 속성값으로 새로운 함수가 들어오면 함수에 null 인수를 넣어서 호출한다 */}
        	{/* 그리고 새로운 함수에는 요소의 참조값을 넣어서 다시 호출해주는데 */}
        	{/* 키보드를 입력할 때마다 컴포넌트가 새로 입력되는데 INITIAL_TEXT도 계속 입력되기에 문제가 발생 */}
  
  				{/* 해결 방법 */}
        	{/* useCallback 훅의 메모이제이션 기능을 이용해 한번 생성된 setInitialText 함수를 재사용함 */}
        )}
        <button> onClick={() => setShowText(!showText)}보이기/가리기</button>
      </div>
    );
  }
  
  const INITIAL_TEXT = '안녕하세요';
  
  ```
  



### 리액트 내장 훅

1. **useRef**

   ref 객체는 꼭 돔 요소를 참조할 때만 사용할 수 있는 것은 아니다.

   **(1) 렌더링과 관계없는 로직 데이터를 관리**하기에도 좋다 이유는 아래 예시에 주석으로!

   ```react
   import React, { useState, useRef, useEffect } from 'react';
   
   export default function App() {
     // 렌더링과 관계없는 로직을 위한 데이터에
     // useRef가 유용하게 사용될 수 있다!
     const timerIdRef = useRef(-1);
     useEffect(() => {
       timerIdRef.current = setTimeout(() => {}, 1000);
     });
     // ...
     useEffect(() => {
       if (timerIdRef.current >= 0) {
         clearTimeout(timerIdRef.current);
       }
     });
     // ...
   }
   
   // 여기서 useState를 쓸 수도 있겠지만
   // 그렇다면 다시 렌더링이 된다. 하지만 UI 데이터가 아니기에 렌더링 결과는 같다
   // 불필요하게 렌더링만 발생하므로 그래서 ref 객체가 더 적합하다
   ```

   또한 **(2) 이전 상태값을 기억하고자 할 때 활용**할 수 있다

   ```react
   import React, { useState, useRef, useEffect } from 'react';
   
   export default function App() {
     const [age, setAge] = useState(20);
     const prevAgeRef = useRef(20);
     useEffect(() => {
       prevAgeRef.current = age;
     }, [age]);
     const prevAge = prevAgeRef.current;
     const text = age === prevAge ? 'same' : age > prevAge ? 'older' : 'younger';
     return (
       <div>
         <p>{`age ${age} is ${text} than age ${prevAge}`}</p>
         <button
           onClick={() => {
             const age = Math.floor(Math.random() * 50 + 1);
             setAge(age);
           }}
         >
           나이 변경
         </button>
       </div>
     );
   }
   ```

   

2. **useMemo**

   계산량이 많은 함수의 반값을 재활용하는 용도로 활용

   ```react
   export default function App() {
     const [v1, setV1] = useState(0);
     const [v2, setV2] = useState(0);
     const [v3, setV3] = useState(0);
     const value = useMemo(() => {
       runExponsiveJob(v1, v2)
       // useEffect와 마찬가지로 useMemo의 두 번째 배열은 의존성 배열
     }, [v1, v2]);
     return (
       <>
         <p>{`value is ${value}`}</p>
         <button
           onClick={() => {
             setV1(Math.random());
             setV2(Math.random());
           }}
         >
           v1/v2 수정
         </button>
         <p>{`v3 is ${v3}`}</p>
         <button onClick={() => setV3(Math.random())}>v3 수정</button>
       </>
     );
   }
   ```

   

3. **useCallback**

   useCallback 훅도 useMemo 훅과 유사하게 메모이제이션 기능을 이용하는데 함수 메모이제이션에 특화되어있다고 보면 된다. 함수를 입력해서 속성값으로 전달할 때는 컴포넌트가 렌더링 될 때마다 새로운 함수가 생성되어 입력된다.

   ```react
   import React, { useState } from 'react';
   
   export default function App() {
     const [name, setName] = useState('');
     const [age, setAge] = useState(0);
     const [v1, setV1] = useState(0);
     return (
       <div>
         <p>{`name is ${name}`}</p>
         <p>{`age is ${age}`}</p>
         <UserEdit
           onSave={() => saveToServer({name, age})}
           setName={setName}
           setAge={setAge}
         />
         <p>{`v1: ${v1}`}</p>
      		{/* 아래 버튼을 눌러 v1 값이 변경되면 새로운 함수가 만들어져 전달되기 때문에*/}
         {/* name, age는 변하지 않지만 UserEdit 컴포넌트의 */}
         {/* 콘솔이 나오는 것을 확인할 수 있다 */}
         <button onClick={() => setV1(Math.random())}>v1 수정</button>
       </div>
     );
   }
   
   const UserEdit = React.memo(function ({ onSave, setName, setAge }) {
     console.log('UserEdit render');
     return null;
   });
   
   function saveToServer(name, age) {}
   ```

   UserEdit 컴포넌트 onSave에 useCallback을 다음과 같이 사용한다

   ```react
   // 맨 뒤 배열은 의존성 배열임
   const onSave = useCallback(() => saveToServer(name, age), [name, age]);
   return (
     <div>
       <p>{`name is ${name}`}</p>
       <p>{`age is ${age}`}</p>
       <UserEdit
         onSave={onSave}
         setName={setName}
         setAge={setAge}
       />
       <p>{`v1: ${v1}`}</p>
       <button onClick={() => setV1(Math.random())}>v1 수정</button>
     </div>
   );
   ```

   이렇게 작성하면 버튼을 눌러도 컴포넌트에 다시 렌더링이 일어나지 않는 것을 확인할 수 있다.

   

4. **useReducer**

   여러 개의 상태 값을 관리할 때는 useReducer가 사용하기 좋다. 상태값을 다루는 로직을 분리해서 관리하기 좋다는 장점이 있다.

   ```react
   export default function App() {
     // 상태값과 useState처럼 상태값을 변경할 수 있는 dispatch 함수가 반환된다
     // 매개변수로 reducer라는 함수와 초기값을 입력한다
     const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
     return (
       <div>
         <p>{`name is ${state.name}`}</p>
         <p>{`age is ${state.age}`}</p>
         <input
           type="text"
           value={state.name}
           // dispatch에서 입력한 객체가 reducer의 action으로 들어오게 된다
           onChange={e => 
             dispatch({ type: 'setName', name: e.currentTarget.value })
           }
         />
         <input
           type="number"
           value={state.age}
           onChange={e => dispatch({ type: 'setAge', age: e.currentTarget.value })}
         />
       </div>
     );
   }
   
   const INITIAL_STATE = { name: 'empty', age: 0 };
   const MAX_AGE = 50;
   // 상태값을 변경하는 로직을 분리하는 장점이 있다
   function reducer(state, action) {
     switch (action.type) {
       case 'setName':
         return { ...state, name: action.name };
       case 'setAge':
         if (action.age > MAX_AGE) {
           return { ...state, age: MAX_AGE };
         } else {
           return { ...state, age: action.age };
         }
       default:
         return state;
     }
   }
   ```

   보통 리액트로 코딩할 때 상위 컴포넌트에서 다수의 상태값을 관리한다. 이때 자식 컴포넌트로부터 발생한 이벤트에서 상위 컴포넌트의 상태을 변경해야 하는 경우가 많이 발생하는데, 이를 위해 상위 컴포넌트에서 트리의 깊은 곳까지 처리 함수를 전달하는 상황이 발생하기도 한다. 이 작업은 상당히 손이 많이 가고 코드의 가독성도 떨어지게 만든다. 

   이 때, useReducer Hook 과 Context api를 같이 이용하면 상위 컴포넌트에서 트리 깊은 곳으로 이벤트 처리 함수를 쉽게 전달할 수 있다. (이러한 패턴으로 작성해도 꽤 괜찮게 상태값을 관리할 수 있다. 리덕스를 사용했을 때 더 많은 장점이 있긴 하다)

   ```react
   // Context api 생성
   export const ProfileDispatch = React.createContext(null);
   
   export default function App() {
     const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
     return (
       <div>
         <p>{`name is ${state.name}`}</p>
         <p>{`age is ${state.age}`}</p>
      		{/* 상위 컴포넌트에서 Provider 컴포넌트를 이용해서 */}
         {/* useReducer의 dispatch 함수를 내려준다 */}
         <ProfileDispatch.Provider value={dispatch}>
           <SomeComponent />
         </ProfileDispatch.Provider>
       </div>
     );
   }
   
   const INITIAL_STATE = { name: 'empty', age: 0 };
   function reducer(state, action) {
     switch (action.type) {
       case 'setName':
         return { ...state, name: action.name };
       case 'setAge':
         return { ...state, age: action.age };
       default:
         return state;
     }
   }
   ```

   

5. **useImperativeHandle**

   클래스형 컴포넌트의 부모 컴포넌트는 ref 객체를 통해서 자식 컴포넌트의 메서드를 호출할 수 있다. 이 방식은 자식 컴포넌트의 내부 구현에 대한 의존성이 생기므로 지양하는 게 맞지만 종종 필요할 때가 있다. 그럴 때, useImperativeHandle 훅을 이용하면 함수형 컴포넌트에서도 마치 멤버 변수나 멤버 함수가 있는 것처럼 만들 수 있다.

   ```react
   // 자식 컴포넌트
   // 속성 값은 쓰지 않고 ref 값만 사용하고 있다
   function Profile(_, ref) {
     const [name, setName] = useState('mike');
     const [age, setAge] = useState(0);
   
     // Profile의 첫 번째 매개변수로 ref 속성 값을 받아서 사용하고 있고
     // 두 번째 매개변수로 함수를 입력받고 있는데, 이 함수가 반환한 값이 부모의 ref 객체가 참조하는 값이 된다.
     useImperativeHandle(ref, () => ({
       addAge: value => setAge(age + value),
       getNameLength: () => name.length,
     }));
   
     return (
       <div>
         <p>{`name is ${name}`}</p>
         <p>{`age is ${age}`}</p>
         {/* ... */}
       </div>
     );
   }
   
   // ref 속성값을 받기 위해 forwardRef 함수를 사용
   export default forwardRef(Profile);
   ```

   ```react
   // 부모 컴포넌트
   import React, { useRef } from 'react';
   import Profile from './Profile';
   
   export default function App() {
     const profileRef = useRef();
     const onClick = () => {
       // 여기서 current는 useImperativeHandle의 두 번째 매개변수인 함수의 반환값을 참조하게 된다
       // 따라서 자식 컴포넌트에서 제공한 getNameLength, addAge 두 개의 함수를 사용할 수 있게 된다.
       if (profileRef.current) {
         console.log('cuurent name length:', profileRef.current.getNameLength());
         profileRef.current.addAge(5);
       }
     };
     return (
       <div>
         <Profile ref={profileRef} />
         <button onClick={onClick}>add age 5</button>
       </div>
     )
   }
   ```

   

6. **useLayoutEffect**

   useEffect 훅에 입력된 **부수효과 함수 렌더링 결과 돔에 반영된 후에 비동기로 호출**이 된다. 이와 달리 useLayoutEffect 훅은 **부수효과 함수를 동기로 호출**한다. 즉, 부수효과 함수가 렌더링 결과가 돔에 반영된 직후에 바로 호출된다. 그래서 렌더링 직후에 돔 요소의 값을 읽어들이는 경우 또는 조건에 따라서 컴포넌트를 다시 렌더링 하고 싶은 경우 사용하는 것이 적합하다.

   주의 : 특별한 이유가 없으면 그렇기 때문에 useLayoutEffect 훅의 부수 효과 함수에서 연산을 많이 하면 브라우저가 먹통이 될 수도 있다! 그렇기에 useEffect 훅이 성능 상 이점을 가져갈 수 있고 실제로 대부분 처리가 가능하다.

   ```react
   import React, { useState, useEffect } from 'react';
   
   export default function App() {
     const [width, setWidth] = useState(200);
   	// 문제를 일으키는 부분
     // 리액트가 렌더링을 하고 실제 돔에 반영은 했지만(트리 구조에 따라 수정)
     // 브라우저가 화면을 그리고 나서(DOM 렌더링) useEffect 실행이 된다.
     useEffect(() => {
       if (width > 500) {
         setWidth(500);
       }
     }, [width]);
     return (
       <div>
         <div style={{ width, height: 100, backgroundColor: 'green' }}>test</div>
         {/* 500 이하 버튼에서는 정상적으로 보임*/}
         <button
           onClick={() => {
             const value = Math.floor(Math.random() * 499 + 1);
             setWidth(value);
           }}
         >
           500 이하
         </button>
         {/* width 값이 500 초과인 경우 처음 랜덤 값으로 렌더링이 된 후에 useEffect에서 */}
         {/* 500으로 다시 한번 렌더링을 하기 때문에 500으로 큰 값으로 렌더링을 했다가 */}
         {/* 500으로 다시 렌더링을 하는 과정에 깜빡이는 것이 보인다 */}
         {/* 이 때 useLayoutEffect를 사용하면 문제를 해결할 수 있다 */}
         <button
           onClick={() => {
             const value = Math.floor(Math.random() * 500 + 501);
             setWidth(value);
           }}
         >
           500 이상
         </button>
       </div>
     );
   } 
   ```

   useLayoutEffect의 작동 방식에 대한 테스트 콘솔, 단점 테스트

   ```react
   const [width, setWidth] = useState(200);
     const boxRef = useRef();
     useLayoutEffect(() => {
       // Effect가 끝난 뒤 실제 width 값 출력
       console.log(boxRef.current.getBoundingClientRect().width)
       if (width > 500) {
         setWidth(500);
       }
       // 연산이 많은 함수 추가하여 브라우저 반응이 늦는 것을 확인
       let v = 0;
       for(let i=0; i<1000000000; i++) {
         v += i * 2 + i;
       }
     }, [width]);
   ```

   

7. **useDebugValue**

   커스텀 훅안에서 사용하면 해당 훅을 사용하면 리액트 개발자 도구에 좀 더 풍부한 정보를 제공해줄 수 있다

   리액트 개발자 도구는 components로 나타나는데 등록한 hooks의 정보(useChangeAppState)가 나타난다

   ```react
   import { useState, useDebugValue } from "react";
   
   export default function useChangeAppState() {
     const [state, setState] = useState(STATE_START);
     // next 함수에 의해 
     const next = () => setState(state === STATE_STOP ? STATE_START : state + 1);
     useDebugValue(
       state === STATE_START
         ? 'start'
         : state === STATE_RUNNING
         ? 'running'
         : 'stop',
     );
     return [state, next];
   }
   
   export const STATE_START = 0;
   export const STATE_RUNNING = 1;
   export const STATE_STOP = 2;
   ```

   ```react
   import React from 'react';
   import useChangeAppState, {
     STATE_START,
     STATE_RUNNING,
   } from './7-1-useDebugValue';
   
   export default function App() {
     const [state, next] = useChangeAppState(true);
     const msg = 
       state === STATE_START
         ? '앱 시작'
         : state === STATE_RUNNING
     		// ? '앱 실행 중'
     		// 아래 라인이 버그인 부분 => 앱 실행 중이어야함
         ? '앱 시작'
         : '앱 종료';
     return (
       <div>
         <p>{msg}</p>
         <button onClick={next}>next</button>
       </div>
     )
   }
   ```

   

### 추천하는 컴포넌트 파일 작성법

* propTypes

  속성값 타입 정보를 가장 위에 작성하는 이유는 먼저 컴포넌트를 사용하는 입장에서 한번 생각해보면 컴포넌트를 사용하고자 속성값을 입력하려 할 때 올바른 값을 입력하려면 타입 정보를 제대로 알아야 하기 때문! 또한 컴포넌트 작성자 입장에서도 속성값 타입은 다른 코드들 보다 중요도가 높기에 상단에 작성하서 관리하기 용이하게 한다. 타입스크립트를 사용한다면 propTypes 속성을 사용할 필요는 없다

  ```react
  // 함수의 propTypes 라는 속성을 이용해서 객체를 입력해줄 수 있는데
  // 이를 통해 속성값의 타입 정보를 입력하는 것이다
  MyComponent.propTypes = {
    // ...
  };
  
  // 컴포넌트 매개변수는 아래와 같이 명명된 매개변수 문법으로 작성하는 것이 좋다.
  // 객체를 그대로 받아오면 반복적으로 써줘야하기 떄문
  export default function MyComponent({ prop1, prop2 }) {
    // MyComponent(props)이라면
    // props.prop1
    // props.prop2
    // ...
  }
  
  // 컴포넌트 바깥에 있는 변수와 함수는 파일의 가장 밑에 작성해야 좋다
  // 변수명은 대문자로 작성!
  // 1. 컴포넌트 코드 안에서 다른 코드와 섞여 있을 때
  // 이 코드는 변하지 않는 외부 변수라는 것을 한 눈에 파악하기 좋기 때문
  // 2. 다소 커다란 크기의 객체를 생성할 때 외부에서 생성해서 쓰는 것이 좋다.
  // 컴포넌트 함수가 실행이 될 때마다 커다란 객체가 매번 생성되기 때문
  const COLUMNES = [
    { id: 1, name: 'phoneNumber', width: 200, color: 'white' },
    { id: 1, name: 'city', width: 100, color: 'grey' },
    // ...
  ];
  const URL_PRODUCT_LIST = 'api/products';
  function getTotalPrice({ price, total }) {
    // ...
  }
  ```

  2번 째 예시

  컴포넌트에서 서로 연관된 코드는 한 곳으로 모아서 관리하는 것을 추천

  ```react
  // 아래와 같이 훅 별로 useState, useEffect를 따로 작성하기 보단
  // 서로 연관된 코드끼리 모아서 작성하는 것이 가독성이 좋다.
  function Profile({ userId }) {
    const [user, setUser] = useState(null);
    const [width, setWidth] = useState(window.innerWidth);
    useEffect(() => {
      getUserApi(userId).thne(data => setUser(data));
    }, [userId])
    userEffect(() => {
      const onResize = () => setWidth(window.innerWidth);
      window.addEventListener('resize', onResize);
      return () => {
        window.removeEventListener('resize', onResize);
      };
    }, []);
    // ...
  }
  
  function ProfileRecommended({ userId }) {
    // 이렇게 따로 분리해두면 커스텀 훅으로 분리하기도 용이하다
    const [user, setUser] = useState(null);
    useEffect(() => {
      getUserApi(userId).thne(data => setUser(data));
    }, [userId]);
    
    const [width, setWidth] = useState(window.innerWidth);
    userEffect(() => {
      const onResize = () => setWidth(window.innerWidth);
      window.addEventListener('resize', onResize);
      return () => {
        window.removeEventListener('resize', onResize);
      };
    }, []);
    // ...
  }
  
  function ProfileCustomHook({ userId }) {
    // 이렇게 따로 분리해두면 커스텀 훅으로 분리하기도 용이하다
    const user = useUser(userId);
    const width = useWindowWidth();
  
    // ...
  }
  ```

  

### 속성값 타입 정의하기 (prop-types)

prop-types 패키지는 속성값의 타입 정보를 정의할 때 사용하는 리액트 공식 패키지다. 사전에 타입 검사를 할 수 있어 TypeScript 만큼은 아니지만 어느정도 도움이 된다.

* **타입이 왜 필요할까?**

  JS는 동적 타입 언어라서 타입에 대한 고민 없이 프로그램을 작성할 수 있고 바로 실행시킬 수도 있다. 따라서 쉽게 배워 간단한 프로젝트를 만들기 쉽다. 하지만 큰 규모의 프로그램을 작성할 때는 생산성이 떨어진다. 따라서 정적 타입 언어로서 사용하는 것이 좋다. TS가 인기를 얻는 이유도 이와 같다.

* **정적 타입의 장점**

  타입 정의 자체가 훌륭한 문서가 된다.

  ```react
  import PropTypes from 'prop-types';
  
  User.propTypes = {
    male: PropTypes.bool.isRequired,
    age: PropTypes.number,
    type: PropTypes.oneOf(['gold', 'silver', 'bronze']),
    onChangeName: PropTypes.func,
    onChangeTitle: PropTypes.func.isRequired,
  };
  // 다만 아쉬운 것은 onChangeName, onChangeTitle은 둘 다 같은 함수 타입이지만
  // 함수의 매개변수나 반환값에 대한 정보가 보이지 않는다
  // 대신 이에 대해 주석으로 자세한 타입을 적어두면 좋다
  ```




### 가독성을 높이는 조건부 렌더링 작성 방법

```react
// 2 번째
// 때에 따라선 아래 삼항 연산자로 구현한 것보다 if문으로 작성한 것이 낫다고 보일 수 있다.
function GreetingA({ isLogin, name }) {
  if (isLogin) {
    return (
      <p className="greeting" onClick={showMenu}>
        {`${name}님 안녕하세요.`}
      </p>
    );
  } else {
    return (
      <p className="noAuth" onClick={goToLoginPage}>
        권한이 없습니다.
      </p>
    );
  }
}

function GreetingB({ isLogin, name }) {
  return (
    <p 
      className={isLogin ? 'greeting' : 'noAuth'}
      onClick={isLogin ? showMenu : goToLoginPage}
    >
      {isLogin ? `${name}님 안녕하세요.` : '권한이 없습니다.'}
    </p>
  );
}
```

```react
// 3 번째
// 이런 식으로 더 깔끔하게 축약해서 보여줄 수 있음
function Greeing({ isLogin, name, cash }) {
  return (
    <div>
      저희 사이트에 방문해 주셔서 감사합니다.
      {isLogin ? (
        <div>
          <p>{name}님 안녕하세요.</p>
          <p>현재 보유하신 금액은 {cash}원입니다.</p>
        </div>
      ) : null}
    </div>
  );
}
```

```react
// 4 번째
// null을 활용하기 보다는 && 기호를 사용하는 것을 추천
// null을 안써도 되기 때문
function Greeting({ isLogin, name, cash }) {
  return (
    <div>
      저희 사이트에 방문해 주셔서 감사합니다.
      {isLogin && (
        <div>
          <p>{name}님 안녕하세요.</p>
          <p>현재 보유하신 금액은 {cash}원입니다.</p>
        </div>)
      }
    </div>
  )
}
```

```react
// 삼항연산자 중첩으로 쓰는 경우
// 한 눈에 어떤 로직으로 보여주는지 파악하기 어렵다
function Greeting({ isEvent, isLogin, name, cash }) {
  return (
    <div>
      저희 사이트에 방문해 주셔서 감사합니다.
      {isEvent ? (
        <div>
          <p>오늘의 이벤트를 놓치지 마세요.</p>
          <button onClick={onClickEvent}>이벤트 참여하기</button>
        </div>
      ) : isLogin ? (
        cash <= 100000 ? (
          <div>
            <p>{name}님 안녕하세요.</p>
            <p>현재 보유하신 금액은 {cash}원입니다.</p>
          </div>
        ) : null
      ) : null}
    </div>
  );
}
```

```react
// 위 코드 개선 버전
// 한 눈에 조건을 확인하기 편해짐
function Greeting({ isEvent, isLogin, name, cash }) {
  return (
    <div>
      저희 사이트에 방문해 주셔서 감사합니다.
      {isEvent && (
        <div>
          <p>오늘의 이벤트를 놓치지 마세요.</p>
          <button onClick={onClickEvent}>이벤트 참여하기</button>
        </div>
      )}
      {!isEvent && isLogin && cash <= 100000 && (
          <div>
            <p>{name}님 안녕하세요.</p>
            <p>현재 보유하신 금액은 {cash}원입니다.</p>
          </div>
      )}
    </div>
  );
}
```

```react
// && 연산자로 렌더링 시 주의할 점
// cash가 Number 타입이므로 0인 경우
// 뒤에 렌더링이 되지 않고 0만 덩그러니 렌더링 될 수 있으므로
// 아래 줄과 같이 !!을 통해 Boolean 타입으로 변환해준다
<div>
  {/* {cash && <p>{cash}원 보유 중</p>} */}
  {!!cash && <p>{cash}원 보유 중</p>}
  {memo && <p>{200 - memo.length}자 입력 가능</p>}
</div>

// 만약 0원이거나 비어있는 문자열('')이어도 표현하고 싶다면
// && 연산자를 아래와 같이 앞의 항을 != null을 붙여 렌더링하는 것을 추천
// 만약 cash가 null이나 undefined가 될 수가 없다면
// 조건부 렌더링을 할 필요가 없다
<div>
  {cash != null && <p>{cash}원 보유 중</p>}
  {memo != null && <p>{200 - memo.length}자 입력 가능</p>}
</div>

// undefined 검사 코드
{/* <div>{student && students.map(...)}</div> */}
// 되도록 undefined가 가능한 변수는 앞에 검사하는 코드가 필요하기에
// 빈 배열을 초기값으로 할당하여 하나의 코드로 가능하도록 하면 좋다
<div>{students.map(/* */)}</div>

```



### 재사용성을 고려한 컴포넌트 구분법

코드의 재사용성과 가독성을 올리려면 **관심사의 분리**가 필요하다. 여기서, 관심사의 분리란 복잡한 코드를 비슷한 기능을 하는 코드끼리 모아서 별도로 관리하는 것을 말한다. UI를 처리하는 코드나 서버 api를 호출하는 코드 또는 DB를 관리하는 코드 같은 것을 같은 파일 안에서 관리하면 복잡해 지기에, 이들이 서로 관심사가 다르다고 보고 파일을 분리해서 관리하는 게 좋다. 코드를 작성하다가 내용이 복잡해진다면 관심사의 분리가 필요한 순간인지 생각해보는 게 좋다!

마찬가지로, 하나의 컴포넌트 안에서 모든 기능을 구현할 수 없기에 우리는 여러 개의 컴포넌트를 만들어서 조립을 한다. 만약 하나의 폴더 안에 모든 컴포넌트를 모아놓고 작업한다면 시간이 흐를수록 컴포넌트가 너무 많아져서 원하는 컴포넌트를 찾기 어려워 질 것이다. 그래서 연관된 컴포넌트끼리 폴더를 만들어서 관리하면 좋다. 예시로 간단한 프로젝트라면 페이지를 폴더 이름으로 하여 해당 페이지에서 활용되는 컴포넌트를 모아 관리할 수 있다. 하지만 복잡한 프로젝트인 경우 상태값이 컴포넌트의 여기저기에 흩어져 있거나 중복이 발생할 수 있다.

* 첫 번째 예시

  ```react
  function TodoList({ todos }) {
    const [doneList, setDoneList] = useState(todos.filter(item => item.done));
    // 아래 함수에서 부모의 데이터를 자식 컴포넌트에서 변형을 주고있음
    // 이는 부모가 가진 데이터와 정합이 맞지 않아 대개 이런 상황은 버그로 이어지게 된다.
    // 따라서 상태값은 일부 컴포넌트로 한정해서 관리하는 것이 좋다.
    function onChangeName(key, name) {
      setDoneList(
        doneList.map(item => (item.key === key ? { ...item, name } : item)),
      );
    }
    // ...
  }
  ```

* 두 번째 예시

  컴포넌트가 비즈니스 로직이나 상태값을 갖고 있으면 재사용하기 어렵다. 재사용하기 좋도록 분리하기 위해 컴포넌트 코드를 분리하는 기준이 필요하다. 다시 말해, 비즈니스 로직과 상태값이 없는 것이 재사용성이 좋은 컴포넌트라고 말할 수 있다. 단, mouse over와 같은 UI 효과를 위한 상탯값은 제외한다.

  ```react
  import React, { useState } from 'react';
  import { getNextFriend } from './data';
  
  export default function App() {
    const [friends, setFriends] = useState([]);
    const [ageLimit, setAgeLimit] = useState(MAX_AGE_LIMIT);
  
    const friendWithAgeLimit = friends.filter(item => item.age <= ageLimit);
    function onAdd() {
      const friend = getNextFriend();
      setFriends([...friends, friend]);
    }
    function onChangeOption(e) {
      const value = Number(e.currentTarget.value);
      setAgeLimit(value);
    }
  
    return (
      <div>
        <button onClick={onAdd}>친구 추가</button>
        <div>
          <select onChange={onChangeOption} value={ageLimit}>
            {AGE_LIMIT_OPTIONS.map(option => (
              <option key={option} value={option}>
                {option}
              </option>
            ))}
          </select>
          세 이하만 보기
        </div>
        <ul>
          {friendsWithAgeLimit.map(friend => (
            <li key={friend.id}>{`${friend.name} (${friend.age})`}</li>
          ))}
        </ul>
      </div>
    );
  }
  ```

  

### useEffect 실전 활용법 1

useEffect의 개념은 간단하지만 실전에서 막히는 경우가 종종 있다. 특히 의존성 배열을 다루기 까다롭다. 대부분은 의존성 배열을 입력하지 않아도 되지만 종종 필요한 경우가 있다. 의존성 배열을 잘못 관리하면 쉽게 버그로 이어지기 쉬우므로 예시를 통해 체크해보자

* 첫 번째 예시

  ```react
  function Profile({ userId }) {
    const [user, setUser] = useState();
    // useEffect의 부수효과 함수는 Profile 컴포넌트가 렌더링 될때마다 호출되기 때문에
    // 서버의 api를 호출하는 코드가 항상 실행이 된다.
    // 그래서 빈 배열([])을 입력한다면 userId가 바뀌어도 호출되지 않기에
    // 새로운 사용자 정보를 가져오기 못하기 때문에 올바른 해결책이 아니다.
    useEffect(() => {
      fetchUser(userId).then(data => setUser(data));
    }, []);
  
    // 따라서 userId를 의존성 배열에 추가해준다
    useEffect(() => {
      fetchUser(userId).then(data => setUser(data));
    }, [userId]);
    // ...
  }
  ```

* 두 번째 예시

  만약 함수에 매개변수가 추가되어 상태값으로 관리한다면 **의존성 배열**에 입력하는 것을 잊지 않도록 조심

  ```react
  function Profile({ userId }) {
    const [user, setUser] = useState();
    const [needDetail, setNeedDetail] = useState(false);
  
    useEffect(() => {
      fetchUser(userId, needDetail).then(data => setUser(data));
    }, [userId, needDetail]);
    // ...
  }

* 세 번째 예시

  만약 userId가 변경되지 않는 것을 확신한다면 useEffect로 위의 예시처럼 표현하기 보다는 별도의 훅을 만드는 것이 좋다. 

  ```js
  // useOnMounted.js
  import { useEffect } from 'react';
  
  export default function useOnMounted(effect) {
    useEffect(effect, []);
  }
  ```

  ```react
  import useOnMounted from './useOnMounted';
  function Profile({ userId }) {
    const [user, setUser] = useState();
    useOnMounted(() => fetchUser(userId).then(data => setUser(data)));
  	
    // userId가 변경되지 않는 것을 확신할 때는
    // 아래처럼 빈 배열로 입력하기 보다는 명시적으로 hook을 만들어서
    // 시점을 조절해주는 훅을 만들어서 사용하는 것이 낫다
    // useEffect(() => {
    //   fetchUser(userId, needDetail).then(data => setUser(data));
    // }, []);
    // ...
    console.log(user);
    return null;
  }
  function fetchUser() {}
  ```

* 네 번째 예시

  의존성 배열에 필요한 변수를 입력하지 않았을 때 어떤 문제가 발생하는지 알려주는 예시

  ```react
  function MyComponent() {
    const [value1, setValue1] = useState(0);
    const [value2, setValue2] = useState(0);
    // 부수효과 함수 안에서 두 개의 상태값을 사용
    useEffect(() => {
      const id = setInterval(() => console.log(value1, value2), 1000);
      return () => clearInterval(id);
      // 의존성 배열에는 하나의 상태값을 넣음
    }, [value1]);
    return (
    	<div>
        <button onClick={() => setValue1(value1 + 1)}>value1 증가</button>
        <button onClick={() => setValue2(value2 + 1)}>value2 증가</button>
      </div>
    )
  }
  ```

  value2가 변경이 됐을 때, 부수효과 함수가 새로 생성이 되겠지만 의존성 배열에는 value2가 없기 때문에 리액트는 방금 생성된 부수효과 함수를 무시한다. 이러면 value2가 변경이 되더라도 value1이 변경될 때 생성된 함수는 예전의 value2값을 계속 사용하기에 변경된 값을 사용하지 못한다.

* 다섯 번째 예시

  부수효과 함수를 asycn와 await으로 작성하면 문제가 된다. 부수효과 함수의 반환값은 항상 함수 타입이어야하기 때문! async와 await 함수는 Promise 객체를 반환하기 때문에 부수효과 함수가 될 수 없다. 이전에 공부했던 내용으로 반환된 함수는 부수효과 호출 직전과 컴포넌트가 사라지기 직전에 호출될 수 있다.

  ```react
  useEffect(async () => {
    const data = await fetchUser(userId);
    setUser(data);
  }, [userId]);
  ```

  **만약 async와 await을 사용하고 싶다면?** => 함수를 따로 작성해서 사용하는 방식이 있다

  ```react
  // use async & await
  useEffect(() => {
    async function fetchAndSetUser() {
      const data = await fetchUser(userId);
      setUser(data);
    }
    fetchAndSetUser();
  }, [userId]);
  ```

* 여섯 번째 예시

  만약 이렇게 부수효과 안에 있는 함수 안에 있는 fetchAndSetUser 함수를 사용하고 싶다면 바깥으로 꺼내야 한다. 두 번째 예시와 비교하여 보자

  ```react
  // 수정 전
  function Profile({ userId }) {
    const [user, setUser] = useState();
    useEffect(() => {
      async function fetchAndSetUser(needDetail) {
        const data = await fetchUser(userId, needDetail);
        setUser(data);
      }
      fetchAndSetUser(false);
    }, [userId]);
    
    if (!user) {
      return <h1>로딩...</h1>;
    }
    return (
    	<div>
        <h1>{user.name}</h1>
        <p>{`캐시: ${user.cash}`}</p>
        <p>{`계정 생성일: ${user.createdAt}`}</p>
        <button onClick={() => fetchAndSetUser(true)}></button>
        <UserDetail user={user} />
      </div>
    )
  }
  ```

  ```react
  // 바깥에서도 함수를 사용할 수 있도록 수정
  function Profile({ userId }) {
    const [user, setUser] = useState();
    // 수정된 곳의 새로운 문제는 Profile 컴포넌트가 새로 생성될 때마다
    // fetchAndSetUser 함수가 생성이 된다는 것이다.
    
    async function fetchAndSetUser(needDetail) {
      const data = await fetchUser(userId, needDetail);
      setUser(data);
    }
    useEffect(() => {
      fetchAndSetUser(false);
    }, [fetchAndSetUser]);
    
    if (!user) {
      return <h1>로딩...</h1>;
    }
    return (
    	<div>
        <h1>{user.name}</h1>
        <p>{`캐시: ${user.cash}`}</p>
        <p>{`계정 생성일: ${user.createdAt}`}</p>
        <button onClick={() => fetchAndSetUser(true)}></button>
        <UserDetail user={user} />
      </div>
    )
  }
  ```

  ```react
  async function fetchAndSetUser(needDetail) {
    const data = await fetchUser(userId, needDetail);
    setUser(data);
  }
  // 위에서 제시한 문제를 해결하기 위해 useCallback 훅을 이용해 
  // userId가 변경될 때만 함수를 실행시키도록 수정한다.
  const fetchAndSetUser = useCallback(
    async function (needDetail) {
      const data = await fetchUser(userId, needDetail);
      setUser(data);
    },
    [userId],
  );
  ```



### useEffect 실전 활용법 2

가능하다면 의존성 배열을 사용하지 않는 게 좋다. 의존성 배열을 관리하는데 생각보다 많은 시간과 노력이 들어가기 때문이다. 특히 속성값으로 전달되는 함수를 의존성 배열에 넣는 순간, 그 함수는 부모 컴포넌트에서 useCallback 등을 사용해서 자주 변경되지 않도록 신경써서 관리를 해야한다.

* 첫 번째 예시

  ```react
  function Profile({ userId }) {
    const [user, setUser] = useState();
    async function fetchAndSetUser(needDetail) {
      const data = await fetchUser(userId, needDetail);
      setUser(data);
    }
    // 의존성 배열을 입력하지 않는 대신 아래와 같이
    // 부수효과 함수 내에서 실행 시점을 조절할 수 있다
    useEffect(() => {
      // 부수효과 함수 내에서 처리를 하면 그 안에 있는 모든 변수는
      // 항상 최신화된 값을 참조함으로 안심하고 사용할 수 있다
      if (!user || user.id !== userId)
        // 그러므로 아래와 같은 함수는 useCallback 같은 훅을 사용하지 않아도 된다
        fetchAndSetUser(false);
      }
    });
    // ...
  }
  ```

* 두 번째 예시

  이전 상태값을 기반으로 다음 상태값을 계산하기 위해 상태값을 의존성 배열에 추가하는 경우가 있다

  ```react
  // Old Version
  function myComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
      function onClick() {
  		// count 변수를 1씩 증가시키기 위해 해당 변수가 필요핟
        setCount(count + 1);
      }
      window.addEventListener('click', onClick);
      return () => window.removeEventListener('click', onClick);
    }, [count]);
    // ...
  }
  
  // New Version
  function myComponent() {
    const [count, setCount] = useState(0);
    useEffect(() => {
      function onClick() {
        // 상태값 변경 함수의 매개변수로 이전 상태값이 들어오기 때문에 이것으로 바꾼다
        setCount(prev => prev + 1);
      }
      window.addEventListener('click', onClick);
      return () => window.removeEventListener('click', onClick);
      // 위처럼 처리하여, 의존성 배열로 빈 배열을 입력할 수 있게됨
    });
    // ...
  }
  ```

* 세 번째 예시

  여러 상태값을 참조할 때는 어떻게 할 수 있을지에 대한 케이스

  ```react
  // 4.js
  function Timer({ initialTotalSeconds }) {
    const [hour, setHour] = useState(Math.floor(initialTotalSeconds / 3600));
    const [minute, setMinute] = useState(
    	Math.floor((initialTotalSeconds % 3600) / 60),
    );
    const [second, setSecond] = useState(initialTotalSeconds % 60);
    useEffect(() => {
  		// 해당 코드에선 setInterval을 사용한 게 무색하게도 1초마다 clearInterval을 호출하고
      // 다시 setInterval을 호출하게 된다. second가 매초 마다 업데이트 되기 때문
      const id = setInterval(() => {
        if (second) {
          setSecond(second + 1);
        } else if (minute) {
          setSecond(second - 1);
        } else if (hour) {
          setHour(hour - 1);
          setMinute(59);
          setSecond(59);
        }
      }, 1000);
      return () => clearInterval(id);
    }, [hour, minute, second]);
    // ...
  }
  ```

  ```react
  // 5.js
  function Timer({ initialTotalSeconds }) {
    // 여러 상태값을 참조하면서 변경할 때는 useReducer 훅을 사용하는 것이 좋다
    // 또한, dispatch 함수는 변하지 않는 값이므로 의존성 배열에서 제거할 수 있다
    const [state, dispatch] = useReducer(reducer, {
      hour: Math.floor(initialTotalSeconds / 3600),
      minute: Math.floor((initialTotalSeconds % 3600) / 60),
      second: initialTotalSeconds % 60,
    });
    const { hour, minute, second } = state;
    useEffect(() => {
      const id = setInterval(dispatch, 1000);
      return () => clearInterval(id);
    })
    // ...
  }
  
  // 값이 변경하는 로직은 Reducer에서 작성
  function reducer(state) {
    const { hour, minute, second } = state;
    if (second) {
      return { ...state, second: second - 1 };
    } else if (minute) {
      return { ...state, minute: minute - 1, second: 59 };
    } else if (hour) {
      return { hour: hour - 1, minute: 59, second: 59 };
    } else {
      return state;
    }
  }
  // 물론 시, 분, 초를 하나의 객체로 만들어 useState로 관리할 수도 있다
  // 다만 useReducer를 사용하면 다양한 액션과 상태값을 관리하기가 용이하고
  // 상태값 변경 로직을 여러 곳에서 재사용 하기에도 좋다
  ```

* 네 번째 예시

  속성값으로 전달되는 함수는 자주 변경되는 경우가 많다. 내용은 그대로 인데 렌더링할 때마다 변경되는 경우가 자주 일어난다. 이로 인해 부수효과 함수가 불필요하게 자주 호출될 수 있다.

  ```react
  // 6.js
  // 문제 상황
  function MyComponent({ onClick }) {
    useEffect(() => {
      window.addEventListener('click', () => {
        onClick();
        // ...
      });
    }, [onClick]);
    // ...
  }
  ```

  ```react
  // 만약 이를 해결하는 마땅한 방법이 떠오르지 않는다면
  // useRef 훅이 손쉬운 해결책이 될 수 있다
  function MyComponent({ onClick }) {
    const onClickRef = useRef();
    // 렌더링이 될 때마다 ref 객체에 onClick 함수를 넣어주는 것
    useEffect(() => {
      onClickRef.current = onClick;
    })
    useEffect(() => {
      // 그리고 원래 사용하려던 곳에서 useRef 훅을 이용해 호출해준다
      // ref 객체는 의존성 배열에 추가할 필요가 없다
      // 다만 의존성 배열을 제거하기 위해 너무 애쓰게 된다
      window.addEventListener('click', () => {
        onClickRef.current();
        // ...
      });
      // ...
    });
    // ...
  }
  ```

  ```react
  function MyComponent({ onClick }) {
    // useRef를 그냥 바로 쓰면 되지 않나 싶을 수 있지만
    // 이후 있을 리액트 버전에서 concurrent모드가 도입되면
    // 컴포넌트 함수가 실행 됐다고 하더라도 중간에 렌더링이 취소될 수 있다
    // 그러면 렌더링은 취소됐는데 ref 객체에는 잘못된 값이 저장될 수 있으므로
    // 되도록 7.js 버전으로 작성하는 것이 좋다
    const onClickRef = useRef();
    onClickRef.current = onClick;
  }
  ```

  
