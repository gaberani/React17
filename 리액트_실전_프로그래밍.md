리액트 실전 프로그래밍

## 1. 리액트 프로젝트 시작하기

### 	- 리액트란 무엇인가

* 자동으로 업데이트 되는 UI 기능만 제공

  따라서 전역 관리 상태나 라우팅, 빌드 시스템을 직접 구축해야함

* render 함수는 순수 함수로 작성

  순수 함수의 특징 입력값이 같으면 출력값이 같다.

  랜덤 함수, 날짜 함수 사용(x)

  외부 상태 변경(x)

* state는 불변 변수로 관리

  어떤 객체의 속성을 변경할 경우, 새로운 객체를 만들어서 값을 할당하는 것이다.

  => 순수 함수와 불변 변수를 활용하면 복잡도가 낮아지고 버그가 발생할 확률도 적다. 리액트의 경우 렌더링 속도도 향상 시킬 수 있는 장점이 있음

### 바벨 사용해 보기

* 자바스크립트 코드를 변환해 주는 컴파일러
* 최신 자바스크립트 문법을 지원하지 않는 환경에서도 최신 문법 사용 가능
* 그 외에도 다양한 용도로 사용
  * 코드에서 주석을 제거 or 코드를 압축
* 리액트에서는 JSX 문법을 사용하기 위해 바벨을 사용한다.

### 웹팩 사용해 보기

* 다양한 기능 제공
  * 파일 내용을 기반으로 파일 이름에 해시값 추가 => 효율적으로 브라우저 캐싱 이용
  * 사용되지 않는 코드 제거
  * 자바스크립트 압축
  * JS에서 CSS, JSON, 텍스트 파일 등을 일반 모듈처럼 불러오기
  * 환경 변수 주입
* 웹팩을 사용하는 가장 큰 이유
  => 모듈 시스템(ESM, commonJS)을 사용하고 싶어서
  * ESM : ES6에서 추가됨
  * c    ommonJS : Node에서 주로 사용

* 요즘 브라우저는 ESM을 지원한다. 하지만..
  * 오래된 브라우저도 지원해야 하는 문제
  * 많은 오픈 소스가 commonJS로 작성됨 => 요즘 브라우저는 commonJS 처리를 못하기 때문에 어쩔 수 없이 웹팩을 사용해야함.




* 실제로 불러오는 모습을 network에서 확인할 수 있다.

![image-20210618234851057](/Users/hyeonsung/Library/Application Support/typora-user-images/image-20210618234851057.png)



### create-react-app으로 시작하기

* 리액트 개발 환경을 직접 구축하기 위해 필요한 노력
  * Webpack, Babel : 빌드 시스템 구축
  * Jest : 테스트 환경 구축
  * Eslint : 코딩 컨벤션 자동 체크
  * Polyfill : 오래된 브라우저를 위한 스크립트 변환
  * HMR : Vue의 핫 리로딩과 같은 기능 (Hot Module Replacement)
  * CSS 후처리 : SASS를 사용할 경우 CSS 컴파일 과정이 필요한 것 또는 오래된 브라우저를 지원하기 위해 벤더 접두사



* cra(create-react-app)을 통해 만들 경우 단점
  * SSR을 쓸 수 없다.
  * 바벨, 웹팩, eslint 등의 설정을 변경할 수 없다.



* index.js - serviceWorker : PWA 사용할 시에 필요
  * serviceWorker.unregister() -> serviceWorker.register()



* App.js에서 로고 img를 자바스크립트에서 import해서 src에 입력을 해주고 있다.

  WHY => CSS나 img 파일을 이와 같은 방식으로 사용할 경우 이미지 경로에 해시 값이 들어가 브라우저 캐싱을 효율적으로 활용할 수 있기 때문



* data의 경우 json파일로 관리할 수 있는데 너무 큰 파일일 때 미리 import해서 무작정 받아오고 보여주는 것이 아니라 필요할 때 받아오게 할 수 있다

  HOW => 클릭되었거나 어떠한 이벤트를 기점으로 import하여 데이터를 클라이언트단에 보여주도록 함

  ```react
  function App() {
    function onClick() {
      import('.data.json').then(({ default: data}) => {
        console.log({ data });
      });
    }
  	return (
    	<button onClick={onClick}>데이터 보여주세요</button>
    )
  }
  ```




### create-react-app으로 시작하기 (2)

* __Package.json 명령어 살펴보기__ 

  * react-scripts start : 개발용, https로 실행시키고 싶다면 `HTTPS=true npm start`

    (Window OS의 경우, `set HTTPS=true && npm start`)

  * react-scripts build : 배포 시 사용, 정적 파일이 생성됨

    로컬에서 정적 파일을 서비스 하고 싶다면 `npx serve -s build` build 폴더를 대상으로 함.

    큰 사이즈의 이미지는 media 폴더에 생성이 되고 작은 사이지의 이미지는 별도 파일로 생성되지 않고 js 파일 안에 내장된다.

  * react-scripts test

    `.spec.js` 또는 `.test.js`면 테스트 파일로 인식, `__test__` 폴더 밑에 있을 경우어떤 이름이든 테스트 파일로 인식

    (개인 의견) 폴더 밑에 .test.js로 붙어있으면 여러모로 관리하기 편함

    WHY => 해당 폴더 내에 있는 기능을 테스트 하는 파일이기에 좋기 때문이라 추측

  * react-scripts eject

    모든 설정 파일을 추출하는 명령어, CRA를 기반으로 직접 개발환경을 구축한다면 사 

* __Polyfill 에 대해__
  * 쓰고자 하는 기능 caniuse.com에서 브라우저 지원 범위 확인
  * Core-js Github에서 해당 기능 경로에 대해 확인
  * CRA의 경우 기본적으로 core-js가 내장되어 있음

* __환경 변수__

  process.env.{변수 이름}

  cra에선 process.env.NODE_ENV 라는 환경변수를 갖고 있음

  실행 명령어에 따라 다르게 읽어옴

  npm start -> 'development'

  npm test -> 'test'

  npm run build -> 'production'

  process.env.REACT_APP_API_URL



### CSS 작성 방법 결정하기

* 일반적인 CSS 파일로 작성하기

  class name이 겹칠 경우 빌드 했을 때 덮어 씌워짐

* css-module로 작성하기

  import할 때 객체 형식으로 보내기 때문에 객체 형식으로 받아서 클래스명을 속성 이름으로 입력해주면 된다.

  객체 안에 속성값을 보면 뒤에 해시 값이 붙어있어 클래스 명이 같아도 고유한 이름을 가짐.

  * classnames라는 패키지를 이용하면 객체 속성 값을 보다 편하게 작성 가능 하다 => ${}의 반복 작성을 피할 수 있음

* Sass로 작성하기

  Sass 문법에 있는 변수나 믹스인 등의 개념을 이용하면 재사용성이 높은 스타일 코드를 작성할 수 있다.

* css-in-js로 작성하기

  css 코드를 js 파일 안에서 작성하는 방식으로 동적으로 css 코드를 작성하기 쉽다.

  css만 담당하는 마크업 개발팀이 별도로 있는 회사일 경우 도입하는데 어려움을 겪을 수 있다. 개발팀원 모두가 css, js를 다룰 수 있다면 도입하기 좋다!

  

  __tagged template literals 문법__

  Styled component에 사용되었던 문법으로 값(css)을 매개변수로 받아서 실행하는 함수처럼 사용

  ```js
  // in box.js 
  // BoxCommon 이라는 div로 이루어진 컴포넌트 생성
  const BoxCommon = styled.div`
    height: 50px;
    background-color: #aaaaaa;
  `;
  
  // BoxCommon을 확장하여 또 다른 컴포넌트 생성 - (1)
  const BoxBig = styled(BoxCommon)`
    width: 200px;
  `;
  
  // BoxCommon을 확장하여 또 다른 컴포넌트 생성 - (2)
  const BoxSmall = styled(BoxCommon)`
    width: 100px;
  `;
  
  // in Button.js
  // 속성 값을 받아 동적으로 처리하기
  const ButtonCommon = styled.button`
    width: ${props => (props.isBig ? 100 : 50)}px;
    height: 30px;
    background-color: yellow;
  `;
  ```

  

### SPA 만들기

![image-20210628224306464](typora-images/image-20210628224306464.png)

* Multi-Page Application **(MPA)**

  초기 요청과 이후 요청에도 모두 HTML 파일로 응답해줌.

* Single-Page Application **(SPA)**

  초기 요청에 HTML을 반환하고 이후 필요할 때만 데이터를 요청해서 받아오는 방식



* SPA가 가능하기 위한 조건

  1. 자바스크립트에서 브라우저로 페이지 전환 요청을 보낼 수 있다.

     (단, 브라우저는 서버로 요청을 보내지 않아야 한다. === 새로운 페이지에 대한 요청이 없다)

  2. 브라우저의 뒤로 가기와 같은 사용자의 페이지 전환 요청을 자바스크립트에서 처리할 수 있다.

     (마찬가지로, 브라우저는 서버로 요청을 보내지 않아야 한다.)

* 이 조건을 만족시켜주는 브라우저 API
  1. pushState, replaceState 함수
  2. popstate 이벤트



* useEffect
  1. 이벤트 핸들러 등록
  2. api를 호출 등 특정 시점에 부수 효과를 일으키고자 할 때 사용하는 리액트 함수



### 리액트 요소와 가상 돔

* **(1) 2-virtual-dom**

  브라우저에서 돔을 변경하는 것은 비교적 오래 걸리는 작업이다. **빠른 렌더링**을 위해 **돔 변경을 최소화**하는 것은 필수!! React는 메모리에 가상돔을 올려 놓고 이전과 이후의 가상돔을 비교하여 **변경된 부분만** 실제 돔에 반영한다.

  **실제 돔에 반영할 변경사항을 찾는 과정**을 따라가 보도록 한다!

  

* **(2) 가상 돔 이해하기**

  jsx 코드는 리액트 요소 트리로 구성된다.

  리액트에서 데이터 변경에 의한 화면 업데이트는 

  1. 렌더 단계 (가상 돔) => 실제 돔에 반영할 변경사항을 파악
  2. 커밋 단계 (실제 돔) => 파악된 변경 사항을 실제 돔에 반영

  을 거친다.

  렌더 단계 에서는 변경 사항을 파악하기 위해 **가상 돔**을 이용하는데 이는 리액트 요소로부터 만들어진다! React는 렌더링을 할 때마다 가상 돔을 만들고 이전 가상 돔과 비교를 한다. 이는 실제 돔의 변경 사항을 최소화하기 위한 과정이다.

  이번 코드를 기반으로 **리액트 요소가 실제 돔으로 만들어지는 과정**에 대해 알아보고자 한다.	



### 리액트 훅(Hook)

* 컴포넌트에 기능을 추가할 때 사용하는 함수

  ex) 컴포넌트에 상태값 추가, 자식 요소에 접근

  리액트 16.8에 새로 추가된 것으로 그 전엔 클래스형 컴포넌트를 사용했다. 클래스형 컴포넌트보다 장점이 많아 리액트 팀도 훅에 집중하고있다. (19년도 kakao con 에서 관련된 영상을 찾을 수 있다.) => 영상이 없어져 블로그 포스팅에 걸려있는 [발표 자료](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=horajjan&logNo=221648675404)로 대체



* 대표적인 훅 두가지!

  1. useState : 상태값 추가

     ```react
     const [{상태값}, {상태값 변경 함수}] = useState({초기값});
     const [count, setCount] = useState(0);
     // 첫 번째 아이템에는 상태값, 두 번째 아이템에는 상태값 변경 함수
     ```

     * 비동기 + 배치 처리

       ```react
       function onClick() {
         setCount(count + 1);
         setCount(count + 1);
       }
       console.log('render called');
       ```

       위와 같이 짜여있는 onClick 함수가 걸려있는 버튼을 클릭하면 count가 1씩 두번 증가할 것이라 생각하지만

       실제론 한번만 증가한다.

       비동기로 처리하는 이유는 동기로 처리할 경우 하나의 상태값 변경 함수가 호출될 때마다 화면을 다시 그리기 때문에 성능상 이슈가 생길 수 있기 때문.

       만약 억지로 위와 같이 처리하고 싶다면 상태값 변경 함수에 함수를 입력해서 다음과 같이 해결할 수 있다.

       ```react
       function onClick() {
         // 처리되기 직전의 상태값을 매개변수로 받는다
         setCount(v => v + 1);
         // 아래도 마찬가지
         setCount(v => v + 1);
       }
       console.log('render called');
       ```

       배치로 처리하는 이유는 onClick 이벤트 핸들러는 리액트 내부에서 관리되는 리액트 요소에 입력이 되어 있기 때문에 배치로 처리하는 것

       만약 리액트에서 관리하지 않는 외부에서 호출하는 경우 배치로 동작하지 않음, 이러한 경우 상태값 변경 함수를 호출할 때마다 렌더링이 발생함.

       ```react
       // 외부에서 처리하여 렌더링이 발생함.
       useEffect(() => {
         window.addEventListener('click', onClick);
         return () => window.addEventListener('click', onClick);
       })
       ```

        이런 상황에서 외부에서 처리 될 때도 배치로 처리되길 원한다면 

       ```react
       function onClick() {
         // unstable_batchedUpdated라는 함수를 호출하면 된다.
         ReactDOM.unstable_batchedUpdated(() => {
           setCount(v => v + 1);
           setCount(v => v + 1);  
         })
       }
       console.log('render called');
       ```

       앞에 unstable이라는 prefix가 붙어있긴 하지만 대부분 이런식으로 사용하고

       나중에 있을 concurrent mode가 추가된다면 외부에서 호출된 함수로 배치로 동작하게 될 것

     * 순서대로 처리된다.

       

  2. useEffect : 부수효과 처리 (여기서 부수효과란 외부의 상태를 변경하는 것을 말한다)

     * 렌더링이 끝나고 항상 호출된다. (ex, 서버 api 호출, 이벤트 핸들러 등록 등에 사용)

     * 컴포넌트 렌더링 중에 부수 효과를 발생시키는 것 프로그램의 복잡도를 크게 증가시키기에 모든 부수 효과는 useEffect 안에서 처리하기를 권장 (지키지 않는다면 유닛테스트 작성하기에 힘들어지는 등 순수 함수가 가지는 여러 장점을 포기하는 것이기 때문)

     * 렌더링이 끝나고 항상 호출되기에 만약에 렌더링이 자주 발생한다면 문제가 된다. 이것을 해결하기 위해 두 번째 매개 변수인 의존성 배열을 입력함으로써 해결할 수 있다. 이 배열에 있는 값이 변경될 때만 부수 효과 함수가 실행됩니다.

       따라서, **컴포넌트의 상태값이나 속성값**, **지역 변수나 지역 함수**같은 것들은 **모두 의존성 배열에 작성**

       <u>setUser와 같은 상태값 변경 함수는 의존성 배열에 작성하지 않아도 된다.</u> 함수가 변경되지 않는다는 것이 보장되기 때문! 

       ```react
       // Profile.js
       // 빈 배열일 경우
       useEffect(() => {
         getUserApi(userId).then(data => setUser(data));
       }, []);
       // => 의존성 배열에 아무것도 담겨있지 않기에 increase 버튼을 눌러도 부수 효과 함수가 실행되지 않고
       //    그로인해 유저 객체가 바뀌지 않음
       ```

       지역 함수인 경우

       ```react
       // Profile.js
       function func1() {
         console.log(userId)
       }
       useEffect(() => {
         func1();
         getUserApi(userId).then(data => setUser(data));
       }, [useId, func1]);
       ```

       Profile 컴포넌트가 렌더링될 때마다 func1이라는 함수가 새로 생성되고 이로 인해 의존성 배열의 값이 항상 변경된다고 볼 수 있다. 이럴 때는 **useCallback** 이라는 훅을 이용해서 **메모이제이션 기능**을 이용할 수 있다.

  3. Custom Hook 만들기

     * 이름은 use로 시작하는 것이 좋다

       코드 가독성이 좋아지고,  여러 리액트 개발 도구의 도움도 쉽게 받을 수 있기 때문

       ```react
       // Profile.js
       export default function Profile({ userId }) {
         // 1. userId가 바뀔 경우
         // 커스텀 훅(useUser) 내부에서 자동으로 api를 호출해서 사용자 데이터를 가져오고
         // 3. 그로인해 컴포넌트도 같이 새로운 유저 정보와 함께 렌더링 된다.
         const user = useUser(userId);
         return (
           <div>
             {!user && <p>사용자 정보를 가져오는 중...</p>}
             {user && (
               <>
                 <p>{`name is ${user.name}`}</p>
                 <p>{`age is ${user.age}`}</p>
               </>
             )}
           </div>
         );
       }
       
       
       // useUser.js
       export default function useUser(userId) {
         // 2. 그로 인해 내부 상태값인 user가 변경된다.
         const [user, setUser] = useState(null);
           useEffect(() => {
             getUserApi(userId).then(data => setUser(data));
           }, [userId]);
         return user;
       }
       ```

* 훅 사용 시 지켜야 할 규칙

  이 두 가지를 지켜야 리액트가 각 훅의 상태를 제대로 기억할 수 있다.

  1. 하나의 컴포넌트에서 훅을 호출하는 순서는 항상 같아야한다.

     If 문 안에 훅을 사용하면 안된다.

     for 문 안에서 사용하면 안된다. useState가 사용되는 횟수가 달라지기 때문

     함수 안에서 훅을 호출하면 안된다. 항상 호출되는 것이 아니기에 순서가 달라짐

     ```react
     // 잘못된 경우
     if (!user) {
       return null
     }
     const [value, setValue] = useState(0);
     /*
     user가 있으면 호출되지만 user가 없다면 호출되지 않으므로 때에 따라 훅이 다르게 호출된다
     이것을 방지하기 위해서 jsx 부분 바로 위에 return 문을 작성하여 이 둘 사이에서 훅을 사용하지 않도록 한다.
     */
     ```

     **Why? 순서가 왜 중요한가?**

     => 우리가 useState에 전달한 정보는 기본값 밖에 없다. useEffect도 마찬가지 어떤 ID 값 같은 것을 제공하지 않는다.

     ​	따라서, React 입장에선 첫 번째 사용된 useState와 두 번째 사용된 useState를 구분하기 위한 정보는 순서 정보밖에 없기 	때문이다.

  2. 훅은 함수형 컴포넌트 또는 커스텀 훅 안에서만 호출되어야 한다.

     

### Context

여러 컴포넌트에서 같은 값을 받아 쓴다면 반복적으로 코드를 작성하게 될 것이다. 이를 위해 사용할 수 있는 것이 **Context** !

* Consumer를 보면 그대로 타고 올라가 가장 가까운 Provider를 찾아 값을 가져다 쓴다. 만약 없다면 CreateContext에서 선언했던 기본값을 활용!

  ```react
  const UserContext = createContext('unknown'); // 기본값과 같이 선언
  
  export default function App() {
    return (
      <div>
        <UserContext.Provider value="mike">
          <div>상단 메뉴</div>
          <Profile />
          <div>하단 메뉴</div>
        </UserContext.Provider>
      </div>
    );
  }
  
  function Profile() {
    return (
      <div>
        <Greeting />
      </div>
    );
  }
  
  function Greeting({ username }) {
    <UserContext.Consumer>
      {username => <p>{`${username}님 안녕하세요`}</p>};
    </UserContext.Consumer>
  }
  ```

* Provider에서 제공하는 value값이 변경되면  **하위의 모든 Consumer 컴포넌트는** 다시 렌더링된다.

  => 여기서 중요한 점은, 중간에 있는 Profile 컴포넌트가 렌더링 되지 않더라도 Greeting (하위) 컴포넌트는 다시 렌더링된다는 것이다. 즉 필요한 하위 컴포넌트만 리렌더링된다.
  
  ```react
  export default function App() {
    const [name, setName] = useState('mike');
    return (
      <div>
        <UserContext.Provider value={name}>
          <div>상단 메뉴</div>
          <Profile />
          <div>하단 메뉴</div>
          <input
            type="text"
            value={name}
            onChange={e => setName(e.target.value)}
          />
        </UserContext.Provider>
      </div>
    );
  }
  // Profile은 memo되어 한 번 렌더링 된 뒤에 변하지 않는다.
  // 실제로 테스트 콘솔문을 작성해두고 App인풋의 값을 변화시켜도 콘솔문이 더이상 나오지 않음을 확인할 수 있다.
  const Profile = React.memo(function() {
    console.log(Profile)
    return (
      <div>
        <Greeting />
      </div>
    );
  });
  ```

* Consumer 안에 있는 변수를 처리하고 싶다면 어떻게 해야 할까?

  ```react
  function Greeting() {
    // 이 부분에서 username을 사용할 수 없다.
    return ( 
      <UserContext.Consumer>
      	{username => <p>{`${username}님 안녕하세요`}</p>};
  	  </UserContext.Consumer>
    )
  }
  
  /*
   * username을 활용하고 싶다면?
   */
  
  // useContext 훅을 직접 사용하면 된다. 그래서 실제론 Consumer를 컴포넌트로 사용하는 일은 거의 없다.
  function Greeting() {
    const username = useContext(UserContext);
    return <p>{`${username}님 안녕하세요`}</p>;
  }
  ```

* 위에 말했던 관련된 Context만 리렌더링 되는 것을 제대로 이용하기 위해서 다른 정보와 묶어서 사용하기 보단 각각 사용해야한다! 해당하는 데이터 값의 변화가 일어났을 때 관련된 Context만 리렌더링되기 때문!

  ```react
  // ThemeContext가 변하면 ThemeContext 훅을 사용하는 부분만 리렌더링 된다.
  // useContext와는 독립적!
  function Greeting() {
    const theme = useContext(ThemeContext);
    const username = useContext(UserContext);
    return (
      <p
        style={{ color: theme === 'dark' ? 'gray' : 'green' }}
      >{`${username}님 안녕하세요`}</p>
    );
  }
  ```

* 만약 하위 컴포넌트에서 데이터를 수정하고 싶다면 어떻게 사용해야 할까?

  ```react
  // => value로 묶어서 사용할 수 있도록 한다!
  export default function App() {
    const [user, setUser] = useState({ username: 'mike', hellocount: 0 });
    return (
      <div>
        <SetUserContext.Provider value={setUser}>
          <UserContext.Provider value={user}>
            <Profile />
          </UserContext.Provider>
        </SetUserContext.Provider>
      </div>
    )
  }
  ```
  
* **Context 사용 시 주의할 점 2가지**

  value에 테스트 코드와 같은 방식으로 묶어서 입력하게 되면 App이 렌더링 될 때마다 새로운 객체가 만들어 진다. 즉, 내부 값({username, age})이 변경되지 않아도 Consumer에선 불필요하게 렌더링될 수 있다.

  * **첫 번째**

    Consumer 컴포넌트와 관계없는 count 값이 늘어나지만 Greeting이 렌더링 되는 것을 확인할 수 있다.

    ```react
    // 테스트 코드
    const UserContext = createContext({ username: 'unknown', age: 0 });
    export default function App() {
      const [username, setUsername] = useState('');
      const [age, setAge] = useState(0);
      const [count, setCount] = useState(0);
      console.log('App render')
      return (
        <div>
          <UserContext.Provider value={{ username, age }}>
            <Profile />
            <button onClick={() => setCount(count + 1)}>증가</button>
          </UserContext.Provider>
        </div>
      )
    }
    
    const Profile = React.memo(function() {
      console.log('Profile render')
      return (
        <div>
          <Greeting />
        </div>
      );
    });
    
    function Greeting() {
      console.log('Greeting render') // count가 늘어나지만 Greeting이 렌더링 된다.
      const username = useContext(UserContext);
      return <p>{`${username}님 안녕하세요`}</p>;
    }
    ```

    **필요없는 컴포넌트까지 렌더링되지 않도록 고친 코드**

    ```react
    const UserContext = createContext({ username: 'unknown', age: 0 });
    export default function App() {
      {/* 
      	const [username, setUsername] = useState('');
      	const [age, setAge] = useState(0);
      */}
      const [user, setUser] = useState({ username: 'mike', age: 0 });
      const [count, setCount] = useState(0);
      return (
        <div>
          {/* <UserContext.Provider value={{ username, age }}> */}
          <UserContext.Provider value={user}>
            <Profile />
            <button onClick={() => setCount(count + 1)}>증가</button>
          </UserContext.Provider>
        </div>
      )
    }
    ```

  * **두 번째**

    Profile의 Consumer가 올라가서 Provider를 만나지 못하는 경우 createContext의 기본값으로 선언한 unknown을 사용하게 될 것이다. 그래서 항상 Provider 컴포넌트 안에서 렌더링 되도록 작성해야 하기에 대부분 루트에서 jsx 부분 전체를 감싸는 방식으로 사용하기에 거의 그럴 일이 없다. 하지만 중간에 Provider 컴포넌트를 작성할 경우 그런 에러를 일으킬 여지가 충분히 있기에 주의를 기울여야 한다!

    ```react
    import React, { useContext, createContext } from 'react';
    
    const UserContext = createContext('unknown');
    
    export default function App() {
      return (
        {/*
        	<div>
          	에러 코드
          	<UserContext.Provider value="mike"> { ... } </UserContext.Provider>
          	<Profile />
        	</div>
        */}
        <div>
          <UserContext.Provider value="mike"}></UserContext.Provider>
          <Profile />
        </div>
      )
    }
    ```




## ref 속성값

리액트로 작업하다보면 실제 DOM 요소에 직접 접근해야 할 때가 있다. 그런 예시로는 돔 요소에 focus를 주거나 크기, 스크롤 위치를 알고 싶은 경우가 있다. 이 때 **ref 속성값**을 이용해 자식 요소에 직접 접근할 수 있는데 이는 컴포넌트일 수도, 돔 요소일 수도 있다.

* 예시 코드

  useRef 훅을 이용해 **(1) 반환된 값**을 **(2) 원하는 요소에 ref속성값으로 입력**해준다.

  ```react
  import React, { useRef, useEffect } from 'react';
  
  export default function App() {
    // (1) 반환된 값 inputRef
    const inputRef = useRef();
    useEffect(() => {
      // current라는 속성을 쓰면 실제 돔 요소를 가리키게 된다.
      inputRef.current.focus();
    }, []);
  
    return (
      <div>
      	{/* (2) 원하는 요소에 입력 input */}
        <input type="text" ref={inputRef} />
        <button>저장</button>
      </div>
    )
  } 
  ```

  **(1) 함수형 컴포넌트**와 **(2) 클래스형 컴포넌트**에서 쓰는 차이

  ```react
  import React, { useRef, useEffect } from 'react';
  
  export default function App() {
    const inputRef = useRef();
    useEffect(() => {
      inputRef.current.focus();
    }, []);
  
    return (
      <div>
        {/* 만약 클래스형 컴포넌트에 사용한다면 */}
        {/* 해당 컴포넌트의 인스턴스를 가리키고 해당 클래스의 메서드를 호출할 수 있게 된다 */}
   			{/* 함수형 컴포넌트는 인스턴스로 만들어지지 않지만 */}
        {/* useImperativeHandle이라는 훅을 사용하면 클래스 컴포넌트차람 변수와 메서드를 사용할 수 있다 */}
        <InputAndSave inputRef={inputRef} />
        <Button ref={buttonRef}>저장</Button>
        <button onClick={() => inputRef.current.focus()}>텍스트로 이동</button>
      </div>
    );
  }
  
  // 별다른 처리를 하지 않았다면 
  // 아래와 같은 함수형 컴포넌트는 인스턴스로 만들어지지 않기에 ref 속성값을 입력할 수는 없다
  // 때문에 App에서 inputRef라는 속성 이름으로 받아서 내부에 있는 자식에게 입력해주고 있다
  // 이렇게 사용해도 상관 없지만 button, input과 같이 기초적이고 직관적인 컴포넌트를 만들고자한다면
  // 그럴 때는 사실 보편적인 buttonRef, inputRef와 같은 독자적인 이름보다 일관성을 위해
  // ref로 입력하는게 좋기에 그렇게 입력하면 리액트가 내부적으로 처리하기 때문에
  // Button 컴포넌트 내부에서 그 값을 사용할 수가 없다
  // 이런 경우를 위해 forwardRef라는 함수를 사용할수 있다 
  function InputAndSave({ inputRef }) {
    return (
      <div>
        <input type="text" ref={inputRef} />
        <button>저장</button>
      </div>
    );
  }
  ```

  **ref 속성값에 함수**를 입력하여 이용할 때 흔히 하는 실수
  
  ```react
  import React, { useState, useCallback } from 'react';
  
  export default function App() {
    const [text, setText] = useState(INITIAL_TEXT);
    const [showText, setShowText] = useState(true);
  
    const setInitialText = useCallback(ref => ref && setText(INITIAL_TEXT), []);
  
    return (
      <div>
        {showText && (
          {/* useRef를 사용하지 않고 함수를 입력할 수 있다 */}
          {/* 입력한 함수는 해당하는 요소가 생성되거나 사라질 때 한 번씩 호출된다 */}
  	      {/* 생성될 때는 해당하는 요소의 레퍼런스가 넘어오고 사라질 때는 null 값이 온다 */}
          <input
            type="text"
            ref={ref => ref && setText(INITIAL_TEXT)}
            value={text}
            onChange={e => setText(e.target.value)}
          />
        	{/* 에러 발생 이유 */}
  	      {/* 컴포넌트가 렌더링 될 때마다 새로운 ref 함수를 입력하고 있기 때문인데 */}
        	{/* 리액트에선 ref 속성값으로 새로운 함수가 들어오면 함수에 null 인수를 넣어서 호출한다 */}
        	{/* 그리고 새로운 함수에는 요소의 참조값을 넣어서 다시 호출해주는데 */}
        	{/* 키보드를 입력할 때마다 컴포넌트가 새로 입력되는데 INITIAL_TEXT도 계속 입력되기에 문제가 발생 */}
  
  				{/* 해결 방법 */}
        	{/* useCallback 훅의 메모이제이션 기능을 이용해 한번 생성된 setInitialText 함수를 재사용함 */}
        )}
        <button> onClick={() => setShowText(!showText)}보이기/가리기</button>
      </div>
    );
  }
  
  const INITIAL_TEXT = '안녕하세요';
  
  ```
  



### 리액트 내장 훅

1. **useRef**

   ref 객체는 꼭 돔 요소를 참조할 때만 사용할 수 있는 것은 아니다.

   **(1) 렌더링과 관계없는 로직 데이터를 관리**하기에도 좋다 이유는 아래 예시에 주석으로!

   ```react
   import React, { useState, useRef, useEffect } from 'react';
   
   export default function App() {
     // 렌더링과 관계없는 로직을 위한 데이터에
     // useRef가 유용하게 사용될 수 있다!
     const timerIdRef = useRef(-1);
     useEffect(() => {
       timerIdRef.current = setTimeout(() => {}, 1000);
     });
     // ...
     useEffect(() => {
       if (timerIdRef.current >= 0) {
         clearTimeout(timerIdRef.current);
       }
     });
     // ...
   }
   
   // 여기서 useState를 쓸 수도 있겠지만
   // 그렇다면 다시 렌더링이 된다. 하지만 UI 데이터가 아니기에 렌더링 결과는 같다
   // 불필요하게 렌더링만 발생하므로 그래서 ref 객체가 더 적합하다
   ```

   또한 **(2) 이전 상태값을 기억하고자 할 때 활용**할 수 있다

   ```react
   import React, { useState, useRef, useEffect } from 'react';
   
   export default function App() {
     const [age, setAge] = useState(20);
     const prevAgeRef = useRef(20);
     useEffect(() => {
       prevAgeRef.current = age;
     }, [age]);
     const prevAge = prevAgeRef.current;
     const text = age === prevAge ? 'same' : age > prevAge ? 'older' : 'younger';
     return (
       <div>
         <p>{`age ${age} is ${text} than age ${prevAge}`}</p>
         <button
           onClick={() => {
             const age = Math.floor(Math.random() * 50 + 1);
             setAge(age);
           }}
         >
           나이 변경
         </button>
       </div>
     );
   }
   ```

   

2. **useMemo**

   계산량이 많은 함수의 반값을 재활용하는 용도로 활용

   ```react
   export default function App() {
     const [v1, setV1] = useState(0);
     const [v2, setV2] = useState(0);
     const [v3, setV3] = useState(0);
     const value = useMemo(() => {
       runExponsiveJob(v1, v2)
       // useEffect와 마찬가지로 useMemo의 두 번째 배열은 의존성 배열
     }, [v1, v2]);
     return (
       <>
         <p>{`value is ${value}`}</p>
         <button
           onClick={() => {
             setV1(Math.random());
             setV2(Math.random());
           }}
         >
           v1/v2 수정
         </button>
         <p>{`v3 is ${v3}`}</p>
         <button onClick={() => setV3(Math.random())}>v3 수정</button>
       </>
     );
   }
   ```

   

3. **useCallback**

   useCallback 훅도 useMemo 훅과 유사하게 메모이제이션 기능을 이용하는데 함수 메모이제이션에 특화되어있다고 보면 된다. 함수를 입력해서 속성값으로 전달할 때는 컴포넌트가 렌더링 될 때마다 새로운 함수가 생성되어 입력된다.

   ```react
   import React, { useState } from 'react';
   
   export default function App() {
     const [name, setName] = useState('');
     const [age, setAge] = useState(0);
     const [v1, setV1] = useState(0);
     return (
       <div>
         <p>{`name is ${name}`}</p>
         <p>{`age is ${age}`}</p>
         <UserEdit
           onSave={() => saveToServer({name, age})}
           setName={setName}
           setAge={setAge}
         />
         <p>{`v1: ${v1}`}</p>
      		{/* 아래 버튼을 눌러 v1 값이 변경되면 새로운 함수가 만들어져 전달되기 때문에*/}
         {/* name, age는 변하지 않지만 UserEdit 컴포넌트의 */}
         {/* 콘솔이 나오는 것을 확인할 수 있다 */}
         <button onClick={() => setV1(Math.random())}>v1 수정</button>
       </div>
     );
   }
   
   const UserEdit = React.memo(function ({ onSave, setName, setAge }) {
     console.log('UserEdit render');
     return null;
   });
   
   function saveToServer(name, age) {}
   ```

   UserEdit 컴포넌트 onSave에 useCallback을 다음과 같이 사용한다

   ```react
   // 맨 뒤 배열은 의존성 배열임
   const onSave = useCallback(() => saveToServer(name, age), [name, age]);
   return (
     <div>
       <p>{`name is ${name}`}</p>
       <p>{`age is ${age}`}</p>
       <UserEdit
         onSave={onSave}
         setName={setName}
         setAge={setAge}
       />
       <p>{`v1: ${v1}`}</p>
       <button onClick={() => setV1(Math.random())}>v1 수정</button>
     </div>
   );
   ```

   이렇게 작성하면 버튼을 눌러도 컴포넌트에 다시 렌더링이 일어나지 않는 것을 확인할 수 있다.

   

4. **useReducer**

   여러 개의 상태 값을 관리할 때는 useReducer가 사용하기 좋다. 상태값을 다루는 로직을 분리해서 관리하기 좋다는 장점이 있다.

   ```react
   export default function App() {
     // 상태값과 useState처럼 상태값을 변경할 수 있는 dispatch 함수가 반환된다
     // 매개변수로 reducer라는 함수와 초기값을 입력한다
     const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
     return (
       <div>
         <p>{`name is ${state.name}`}</p>
         <p>{`age is ${state.age}`}</p>
         <input
           type="text"
           value={state.name}
           // dispatch에서 입력한 객체가 reducer의 action으로 들어오게 된다
           onChange={e => 
             dispatch({ type: 'setName', name: e.currentTarget.value })
           }
         />
         <input
           type="number"
           value={state.age}
           onChange={e => dispatch({ type: 'setAge', age: e.currentTarget.value })}
         />
       </div>
     );
   }
   
   const INITIAL_STATE = { name: 'empty', age: 0 };
   const MAX_AGE = 50;
   // 상태값을 변경하는 로직을 분리하는 장점이 있다
   function reducer(state, action) {
     switch (action.type) {
       case 'setName':
         return { ...state, name: action.name };
       case 'setAge':
         if (action.age > MAX_AGE) {
           return { ...state, age: MAX_AGE };
         } else {
           return { ...state, age: action.age };
         }
       default:
         return state;
     }
   }
   ```

   보통 리액트로 코딩할 때 상위 컴포넌트에서 다수의 상태값을 관리한다. 이때 자식 컴포넌트로부터 발생한 이벤트에서 상위 컴포넌트의 상태을 변경해야 하는 경우가 많이 발생하는데, 이를 위해 상위 컴포넌트에서 트리의 깊은 곳까지 처리 함수를 전달하는 상황이 발생하기도 한다. 이 작업은 상당히 손이 많이 가고 코드의 가독성도 떨어지게 만든다. 

   이 때, useReducer Hook 과 Context api를 같이 이용하면 상위 컴포넌트에서 트리 깊은 곳으로 이벤트 처리 함수를 쉽게 전달할 수 있다. (이러한 패턴으로 작성해도 꽤 괜찮게 상태값을 관리할 수 있다. 리덕스를 사용했을 때 더 많은 장점이 있긴 하다)

   ```react
   // Context api 생성
   export const ProfileDispatch = React.createContext(null);
   
   export default function App() {
     const [state, dispatch] = useReducer(reducer, INITIAL_STATE);
     return (
       <div>
         <p>{`name is ${state.name}`}</p>
         <p>{`age is ${state.age}`}</p>
      		{/* 상위 컴포넌트에서 Provider 컴포넌트를 이용해서 */}
         {/* useReducer의 dispatch 함수를 내려준다 */}
         <ProfileDispatch.Provider value={dispatch}>
           <SomeComponent />
         </ProfileDispatch.Provider>
       </div>
     );
   }
   
   const INITIAL_STATE = { name: 'empty', age: 0 };
   function reducer(state, action) {
     switch (action.type) {
       case 'setName':
         return { ...state, name: action.name };
       case 'setAge':
         return { ...state, age: action.age };
       default:
         return state;
     }
   }
   ```

   

5. **useImperativeHandle**

   클래스형 컴포넌트의 부모 컴포넌트는 ref 객체를 통해서 자식 컴포넌트의 메서드를 호출할 수 있다. 이 방식은 자식 컴포넌트의 내부 구현에 대한 의존성이 생기므로 지양하는 게 맞지만 종종 필요할 때가 있다. 그럴 때, useImperativeHandle 훅을 이용하면 함수형 컴포넌트에서도 마치 멤버 변수나 멤버 함수가 있는 것처럼 만들 수 있다.

   ```react
   // 자식 컴포넌트
   // 속성 값은 쓰지 않고 ref 값만 사용하고 있다
   function Profile(_, ref) {
     const [name, setName] = useState('mike');
     const [age, setAge] = useState(0);
   
     // Profile의 첫 번째 매개변수로 ref 속성 값을 받아서 사용하고 있고
     // 두 번째 매개변수로 함수를 입력받고 있는데, 이 함수가 반환한 값이 부모의 ref 객체가 참조하는 값이 된다.
     useImperativeHandle(ref, () => ({
       addAge: value => setAge(age + value),
       getNameLength: () => name.length,
     }));
   
     return (
       <div>
         <p>{`name is ${name}`}</p>
         <p>{`age is ${age}`}</p>
         {/* ... */}
       </div>
     );
   }
   
   // ref 속성값을 받기 위해 forwardRef 함수를 사용
   export default forwardRef(Profile);
   ```

   ```react
   // 부모 컴포넌트
   import React, { useRef } from 'react';
   import Profile from './Profile';
   
   export default function App() {
     const profileRef = useRef();
     const onClick = () => {
       // 여기서 current는 useImperativeHandle의 두 번째 매개변수인 함수의 반환값을 참조하게 된다
       // 따라서 자식 컴포넌트에서 제공한 getNameLength, addAge 두 개의 함수를 사용할 수 있게 된다.
       if (profileRef.current) {
         console.log('cuurent name length:', profileRef.current.getNameLength());
         profileRef.current.addAge(5);
       }
     };
     return (
       <div>
         <Profile ref={profileRef} />
         <button onClick={onClick}>add age 5</button>
       </div>
     )
   }
   ```

   

6. **useLayoutEffect**

   useEffect 훅에 입력된 **부수효과 함수 렌더링 결과 돔에 반영된 후에 비동기로 호출**이 된다. 이와 달리 useLayoutEffect 훅은 **부수효과 함수를 동기로 호출**한다. 즉, 부수효과 함수가 렌더링 결과가 돔에 반영된 직후에 바로 호출된다. 그래서 렌더링 직후에 돔 요소의 값을 읽어들이는 경우 또는 조건에 따라서 컴포넌트를 다시 렌더링 하고 싶은 경우 사용하는 것이 적합하다.

   주의 : 특별한 이유가 없으면 그렇기 때문에 useLayoutEffect 훅의 부수 효과 함수에서 연산을 많이 하면 브라우저가 먹통이 될 수도 있다! 그렇기에 useEffect 훅이 성능 상 이점을 가져갈 수 있고 실제로 대부분 처리가 가능하다.

   ```react
   import React, { useState, useEffect } from 'react';
   
   export default function App() {
     const [width, setWidth] = useState(200);
   	// 문제를 일으키는 부분
     // 리액트가 렌더링을 하고 실제 돔에 반영은 했지만(트리 구조에 따라 수정)
     // 브라우저가 화면을 그리고 나서(DOM 렌더링) useEffect 실행이 된다.
     useEffect(() => {
       if (width > 500) {
         setWidth(500);
       }
     }, [width]);
     return (
       <div>
         <div style={{ width, height: 100, backgroundColor: 'green' }}>test</div>
         {/* 500 이하 버튼에서는 정상적으로 보임*/}
         <button
           onClick={() => {
             const value = Math.floor(Math.random() * 499 + 1);
             setWidth(value);
           }}
         >
           500 이하
         </button>
         {/* width 값이 500 초과인 경우 처음 랜덤 값으로 렌더링이 된 후에 useEffect에서 */}
         {/* 500으로 다시 한번 렌더링을 하기 때문에 500으로 큰 값으로 렌더링을 했다가 */}
         {/* 500으로 다시 렌더링을 하는 과정에 깜빡이는 것이 보인다 */}
         {/* 이 때 useLayoutEffect를 사용하면 문제를 해결할 수 있다 */}
         <button
           onClick={() => {
             const value = Math.floor(Math.random() * 500 + 501);
             setWidth(value);
           }}
         >
           500 이상
         </button>
       </div>
     );
   } 
   ```

   useLayoutEffect의 작동 방식에 대한 테스트 콘솔, 단점 테스트

   ```react
   const [width, setWidth] = useState(200);
     const boxRef = useRef();
     useLayoutEffect(() => {
       // Effect가 끝난 뒤 실제 width 값 출력
       console.log(boxRef.current.getBoundingClientRect().width)
       if (width > 500) {
         setWidth(500);
       }
       // 연산이 많은 함수 추가하여 브라우저 반응이 늦는 것을 확인
       let v = 0;
       for(let i=0; i<1000000000; i++) {
         v += i * 2 + i;
       }
     }, [width]);
   ```

   

7. **useDebugValue**

   커스텀 훅안에서 사용하면 해당 훅을 사용하면 리액트 개발자 도구에 좀 더 풍부한 정보를 제공해줄 수 있다

   리액트 개발자 도구는 components로 나타나는데 등록한 hooks의 정보(useChangeAppState)가 나타난다

   ```react
   import { useState, useDebugValue } from "react";
   
   export default function useChangeAppState() {
     const [state, setState] = useState(STATE_START);
     // next 함수에 의해 
     const next = () => setState(state === STATE_STOP ? STATE_START : state + 1);
     useDebugValue(
       state === STATE_START
         ? 'start'
         : state === STATE_RUNNING
         ? 'running'
         : 'stop',
     );
     return [state, next];
   }
   
   export const STATE_START = 0;
   export const STATE_RUNNING = 1;
   export const STATE_STOP = 2;
   ```

   ```react
   import React from 'react';
   import useChangeAppState, {
     STATE_START,
     STATE_RUNNING,
   } from './7-1-useDebugValue';
   
   export default function App() {
     const [state, next] = useChangeAppState(true);
     const msg = 
       state === STATE_START
         ? '앱 시작'
         : state === STATE_RUNNING
     		// ? '앱 실행 중'
     		// 아래 라인이 버그인 부분 => 앱 실행 중이어야함
         ? '앱 시작'
         : '앱 종료';
     return (
       <div>
         <p>{msg}</p>
         <button onClick={next}>next</button>
       </div>
     )
   }
   ```

   

   

